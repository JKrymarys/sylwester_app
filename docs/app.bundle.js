zuix.bundle(
/*
 * zUIx Application Bundle
 * 
 * app.bundle.js generated by *zuix-bundler*
 *   on 2019-12-27T13:06:57.572Z
 * 
 * Resource list (14):
 * 
 * - [css] 
 *   ./index.css (_res/style/style-1784725062)
 * 
 * - [js] 
 *   ./service-worker.js (_res/script/script-605580544)
 * 
 * - [html] [css] [js] 
 *   layout/header
 * 
 * - [html] [css] [js] 
 *   layout/footer
 * 
 * - [html] [css] [js] 
 *   pages/home
 * 
 * - [html] [css] [js] 
 *   pages/map
 * 
 * - [html] [css] [js] 
 *   pages/drinks
 * 
 * - [html] [css] [js] 
 *   pages/about
 * 
 * - [js] 
 *   https://zuixjs.github.io/zkit/lib/controllers/view_pager
 * 
 * - [html] [js] 
 *   https://zuixjs.github.io/zkit/lib/controllers/gesture_helper
 * 
 * - [html] [css] [js] 
 *   https://zuixjs.github.io/zkit/lib/components/context_menu
 * 
 * - [js] 
 *   https://zuixjs.github.io/zkit/lib/controllers/header_auto_hide
 * 
 * - [html] [js] 
 *   https://zuixjs.github.io/zkit/lib/controllers/scroll_helper
 * 
 * - [html] [css] [js] 
 *   pages/home/items_list
 * 
 * 
*/

[{"componentId":"_res\u002Fstyle\u002Fstyle-1784725062","view":null,"css":"\u002F* CSS files add styling rules to your content *\u002F\n\nbody {\n    font-family: \"Benton Sans\", \"Helvetica Neue\", helvetica, arial, sans-serif;\n    font-size: 16px;\n    margin: 0; padding: 0;\n    background: black;\n    -webkit-user-select:none;\n    -moz-user-select:none;\n    -ms-user-select:none;\n    user-select:none;\n    overscroll-behavior-y: contain;\n}\n\n.drawer {\n    background: black;\n}\n","controller":null,"using":".\u002Findex.css"},{"componentId":"_res\u002Fscript\u002Fscript-605580544","view":null,"css":null,"controller":"if ('serviceWorker' in navigator) {\n    const p = navigator.serviceWorker\n        .register('.\u002Fsw.js')\n        .then(reg =\u003E console.log('PWA service-worker ready.', reg))\n        .catch(err =\u003E console.error('Could not load service-worker.', err));\n}\n","using":".\u002Fservice-worker.js"},{"componentId":"layout\u002Fheader","view":"\u003Cdiv class=\"header\"\u003E\n  \u003Cdiv class=\"profile pulse\"\u003E\n    \u003Cimg alt=\"Profile Icon\" src=\"images\u002Fprofile_icon.png\"\u003E\n  \u003C\u002Fdiv\u003E\n  \u003Cdiv data-ui-field=\"header-box\" layout=\"row center-center\"\u003E\n    \u003Cdiv class=\"title\"\u003E\n      Home\n    \u003C\u002Fdiv\u003E\n    \u003Cdiv class=\"title\"\u003E\n      Dojazd\n    \u003C\u002Fdiv\u003E\n    \u003Cdiv class=\"title\"\u003E\n      Drineczki\n    \u003C\u002Fdiv\u003E\n    \u003Cdiv class=\"title\"\u003E\n      Inne\n    \u003C\u002Fdiv\u003E\n  \u003C\u002Fdiv\u003E\n\u003C\u002Fdiv\u003E\n\u003Cdiv data-ui-field=\"header-tools\"\u003E\n  \u003Cdiv class=\"topics\" data-ui-load=\"@lib\u002Fcontrollers\u002Fview_pager\" data-ui-options=\"options.topicIndicator\"\u003E\n    \u003Cdiv\u003E\n      Top Stories\n    \u003C\u002Fdiv\u003E\n    \u003Cdiv\u003E\n      World\n    \u003C\u002Fdiv\u003E\n    \u003Cdiv\u003E\n      Europe\n    \u003C\u002Fdiv\u003E\n    \u003Cdiv\u003E\n      Travel\n    \u003C\u002Fdiv\u003E\n  \u003C\u002Fdiv\u003E\n\u003C\u002Fdiv\u003E","css":". {\n  position: fixed;\n  top:0;\n  left:0;\n  right:0;\n  height:auto;\n  background: rgba(0,0,0,0.97);\n  border-bottom: solid 1px rgba(0,0,0,0.25);\n  box-shadow: 0 6px 2px -2px rgba(100,100,100,0.25);\n  z-index: 100;\n}\n\n.header {\n  height: 56px;\n  max-height: 56px;\n}\n\n.title {\n  position: absolute;\n  color: orange;\n  top: 12px;\n  left: 80px;\n  font-size: 180%;\n}\n\n.profile {\n  position: absolute;\n  left: 20px; top: 8px;\n  width: 42px;\n  height: 42px;\n  background: #f5f8fa;\n  border-radius: 50%;\n  border: solid 1px #00aced;\n  overflow: hidden;\n  cursor: pointer;\n}\n.profile img {\n  margin-left: -2px;\n  height: 44px;\n}\n\n.topics {\n  width: 100%;\n  height:40px;\n}\n.topics div {\n  font-size: 16px;\n  height:36px;\n  min-width: 96px;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 36px;\n  border-bottom: solid 4px transparent;\n  cursor: pointer;\n}\n\n.active {\n  color: initial;\n  font-weight: bold;\n  border-bottom: solid 4px #00aced !important;\n}\n\n[data-ui-field=\"header-box\"] {\n  padding-left: 72px;\n  padding-right: 16px;\n  height: 100%;\n}\n\n\u002F* Pulse Animation from https:\u002F\u002Fcodepen.io\u002Folam\u002Fpen\u002Fzcqea *\u002F\n\n.pulse {\n  box-shadow: 0 0 0 rgba(204,169,44, 0.4);\n  animation: pulse 2s infinite;\n}\n.pulse:hover {\n  animation: none;\n}\n\n@-webkit-keyframes pulse {\n  0% {\n    -webkit-box-shadow: 0 0 0 0 rgba(204,169,44, 0.4);\n  }\n  70% {\n    -webkit-box-shadow: 0 0 0 10px rgba(204,169,44, 0);\n  }\n  100% {\n    -webkit-box-shadow: 0 0 0 0 rgba(204,169,44, 0);\n  }\n}\n@keyframes pulse {\n  0% {\n    -moz-box-shadow: 0 0 0 0 rgba(204,169,44, 0.4);\n    box-shadow: 0 0 0 0 rgba(204,169,44, 0.4);\n  }\n  70% {\n    -moz-box-shadow: 0 0 0 10px rgba(204,169,44, 0);\n    box-shadow: 0 0 0 10px rgba(204,169,44, 0);\n  }\n  100% {\n    -moz-box-shadow: 0 0 0 0 rgba(204,169,44, 0);\n    box-shadow: 0 0 0 0 rgba(204,169,44, 0);\n  }\n}\n","controller":function (){}},{"componentId":"layout\u002Ffooter","view":"\u003Cbutton class=\"active\"\u003E\n  \u003Ci class=\"material-icons md-48\"\u003Ehome\u003C\u002Fi\u003E\n\u003C\u002Fbutton\u003E\n\u003Cbutton\u003E\n  \u003Ci class=\"material-icons md-48\"\u003Emap\u003C\u002Fi\u003E\n\u003C\u002Fbutton\u003E\n\u003Cbutton\u003E\n  \u003Ci class=\"material-icons md-48\"\u003Elocal_drink\u003C\u002Fi\u003E\n\u003C\u002Fbutton\u003E\n\u003Cbutton\u003E\n  \u003Ci class=\"material-icons md-48\"\u003Eaudiotrack\u003C\u002Fi\u003E\n\u003C\u002Fbutton\u003E","css":". {\n    position: fixed;\n    left:0; bottom:0; right: 0;\n    height: 56px;\n    \u002F* background: rgba(240,240,240,0.97); *\u002F\n    background: rgba(0,0,0,0.97);\n    border-top: solid 1px rgba(0,0,0,0.25);\n    box-shadow: 0 -6px 2px -2px rgba(100,100,100,0.25);\n    text-align: center;\n    z-index: 100;\n    overflow: hidden;\n}\n\nbutton {\n    padding: 12px;\n    max-height: 56px;\n    margin-left: 8px;\n    margin-right: 8px;\n    background: transparent;\n    border: none;\n    border-radius: 8px;\n    color: rgba(240,240,240,0.5);\n    -webkit-transition: all .3s; \u002F* Safari *\u002F\n    transition: all .3s;\n}\nbutton:hover {\n    background: rgba(255,255,255,0.25);\n}\nbutton:focus {outline:0;}\nbutton i {font-size: 32px !important;}\n\n.active {\n    transform: scale(1.2);\n    color: orange;\n    text-shadow:\n            1px 1px 0 orange,\n            -1px -1px 0 orange,\n            1px -1px 0 orange,\n            -1px 1px 0 orange,\n            1px 1px 0 orange;\n}\n","controller":function (){}},{"componentId":"pages\u002Fhome","view":"\u003Cdiv data-ui-load=\"@lib\u002Fcontrollers\u002Fview_pager\" data-ui-options=\"options.viewPager\" class=\"feed-pager\"\n    draggable=\"false\"\u003E\n\n    \u003C!-- TOP STORIES --\u003E\n    \u003Csection class=\"content\" data-ui-load=\"@lib\u002Fcontrollers\u002Fheader_auto_hide\" data-ui-options=\"options.autoHidingBars\"\u003E\n\n        \u003Cdiv data-ui-load=\"pages\u002Fhome\u002Fitems_list\" data-o-rss=\"http:\u002F\u002Frss.cnn.com\u002Frss\u002Fedition.rss\"\u003E\u003C\u002Fdiv\u003E\n\n    \u003C\u002Fsection\u003E\n\n    \u003C!-- WORLD --\u003E\n    \u003Csection class=\"content\" data-ui-load=\"@lib\u002Fcontrollers\u002Fheader_auto_hide\" data-ui-options=\"options.autoHidingBars\"\u003E\n\n        \u003Cdiv data-ui-load=\"pages\u002Fhome\u002Fitems_list\" data-o-rss=\"http:\u002F\u002Frss.cnn.com\u002Frss\u002Fedition_world.rss\"\u003E\u003C\u002Fdiv\u003E\n\n    \u003C\u002Fsection\u003E\n\n    \u003C!-- EUROPE --\u003E\n    \u003Csection class=\"content\" data-ui-load=\"@lib\u002Fcontrollers\u002Fheader_auto_hide\" data-ui-options=\"options.autoHidingBars\"\u003E\n\n        \u003Cdiv data-ui-load=\"pages\u002Fhome\u002Fitems_list\" data-o-rss=\"http:\u002F\u002Frss.cnn.com\u002Frss\u002Fedition_europe.rss\"\u003E\u003C\u002Fdiv\u003E\n\n    \u003C\u002Fsection\u003E\n\n    \u003C!-- TRAVEL --\u003E\n    \u003Csection class=\"content\" data-ui-load=\"@lib\u002Fcontrollers\u002Fheader_auto_hide\" data-ui-options=\"options.autoHidingBars\"\u003E\n\n        \u003Cdiv data-ui-load=\"pages\u002Fhome\u002Fitems_list\" data-o-rss=\"http:\u002F\u002Frss.cnn.com\u002Frss\u002Fedition_travel.rss\"\u003E\u003C\u002Fdiv\u003E\n\n    \u003C\u002Fsection\u003E\n\n\u003C\u002Fdiv\u003E\n\u003Cdiv data-ui-load=\"@lib\u002Fcomponents\u002Fcontext_menu\" data-ui-context=\"news-options-menu\"\u003E\n    \u003Cdiv data-ui-field=\"menu\"\u003E\n        \u003Cbutton layout=\"row center-left\"\u003E\n            \u003Ci class=\"material-icons\"\u003Ebookmark_border\u003C\u002Fi\u003E\n            \u003Cspan\u003ESave for later\u003C\u002Fspan\u003E\n        \u003C\u002Fbutton\u003E\n        \u003Cbutton layout=\"row center-left\"\u003E\n            \u003Ci class=\"material-icons\"\u003Eshare\u003C\u002Fi\u003E\n            \u003Cspan\u003EShare\u003C\u002Fspan\u003E\n        \u003C\u002Fbutton\u003E\n        \u003Cbutton layout=\"row center-left\"\u003E\n            \u003Ci class=\"material-icons\"\u003Eopen_in_new\u003C\u002Fi\u003E\n            \u003Cspan\u003EOpen link\u003C\u002Fspan\u003E\n        \u003C\u002Fbutton\u003E\n        \u003Cbutton layout=\"row center-left\"\u003E\n            \u003Ci class=\"material-icons\"\u003Enot_interested\u003C\u002Fi\u003E\n            \u003Cspan\u003EHide items from this source\u003C\u002Fspan\u003E\n        \u003C\u002Fbutton\u003E\n        \u003Cbutton layout=\"row center-left\"\u003E\n            \u003Ci class=\"material-icons\"\u003Ethumb_up\u003C\u002Fi\u003E\n            \u003Cspan\u003EMore like this\u003C\u002Fspan\u003E\n        \u003C\u002Fbutton\u003E\n        \u003Cbutton layout=\"row center-left\"\u003E\n            \u003Ci class=\"material-icons\"\u003Ethumb_down\u003C\u002Fi\u003E\n            \u003Cspan\u003ELess like this\u003C\u002Fspan\u003E\n        \u003C\u002Fbutton\u003E\n    \u003C\u002Fdiv\u003E\n\u003C\u002Fdiv\u003E","css":".content {\n    font-family: serif;\n    font-size: 110%;\n    width: 100vw;\n    height: 100vh;\n    overflow-y: scroll;\n}\n\n.feed-pager {\n    height: 100vh;\n    z-index: 0;\n}\n","controller":function (){}},{"componentId":"pages\u002Fmap","view":"\u003C!-- \u003Cdiv self=\"stretch-stretch\" layout=\"row center-center\"\u003E --\u003E\n\u003Cdiv class=\"box\"\u003E\u003Ciframe\n        src=\"https:\u002F\u002Fwww.google.com\u002Fmaps\u002Fembed?pb=!1m18!1m12!1m3!1d5893.164393385241!2d19.3683209300737!3d51.73990120286878!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!3m3!1m2!1s0x471a357e77a8b8cd%3A0x687adb8ad1a4049f!2zS29sYXJza2EgMTY3LCA5MC0wMDEgxYHDs2TFug!5e0!3m2!1sen!2spl!4v1576932228172!5m2!1sen!2spl\"\n        allowfullscreen\u003E\u003C\u002Fiframe\u003E\n\u003C\u002Fdiv\u003E\n\u003C!-- \u003C\u002Fdiv\u003E --\u003E","css":"\u002F* .box {\n    position: relative;\n    padding-bottom: 10%;\n    padding-top: 25px;\n    height: 100%;\n    overflow: hidden;\n  }\n   *\u002F\n  .box iframe {\n    width:100%;\n    height:100%;\n    margin:0;\n    padding-top:20vw;\n    padding-bottom:10vw;\n\n    position:absolute;\n  }\n  ","controller":function (){}},{"componentId":"pages\u002Fdrinks","view":"\u003Cdiv class=\"message\" self=\"stretch-stretch\" layout=\"row center-center\"\u003E\n    \u003Cdiv\u003EDrineczki\u003C\u002Fdiv\u003E\n\u003C\u002Fdiv\u003E","css":".message {\n    color: darkgrey;\n    min-height: 100vh;\n    width: 100vw;\n    font-size: 200%;\n}\n.message i {\n    margin-left: 16px;\n    color: darkgrey;\n    font-size: 150%;\n}\n","controller":function (){}},{"componentId":"pages\u002Fabout","view":"\u003Cdiv self=\"size-small center-center\"\u003E\n\n    \u003Ch2\u003EPrawilna playlista\u003C\u002Fh2\u003E\n\n    \u003Ciframe src=\"https:\u002F\u002Fopen.spotify.com\u002Fembed\u002Fplaylist\u002F0w4Dh5V1zZo4cKWxoJp7Lx\" width=\"300\" height=\"380\"\n        frameborder=\"0\" allowtransparency=\"true\" allow=\"encrypted-media\"\u003E\u003C\u002Fiframe\u003E\n\n\u003C\u002Fdiv\u003E","css":". {\n    color: black;\n    padding: 24px;\n    margin-top: 64px;\n    margin-bottom: 64px;\n}\n\nh1,h2,h3 {\n    color: grey;\n}\n\nh2 {\n    font-size: 130%;\n}\n\na, a:visited, a:hover {\n    font-weight: 700;\n    color: darkorange;\n    text-decoration: none;\n}\n\n.small {\n    font-size: 90%;\n}\n","controller":function (){}},{"componentId":"https:\u002F\u002Fzuixjs.github.io\u002Fzkit\u002Flib\u002Fcontrollers\u002Fview_pager","controller":function (cp) {
    const DEFAULT_PAGE_TRANSITION = {duration: 0.3, easing: 'ease'};
    const BOUNDARY_HIT_EASING = 'cubic-bezier(0.0,0.1,0.35,1.1)';
    const DECELERATE_SCROLL_EASING = 'cubic-bezier(0.0,0.1,0.35,1.0)';
    const LAYOUT_HORIZONTAL = 'horizontal';
    const LAYOUT_VERTICAL = 'vertical';
    const SLIDE_DIRECTION_FORWARD = 1;
    const SLIDE_DIRECTION_BACKWARD = -1;
    // state vars
    let currentPage = -1;
    let oldPage = 0;
    let slideTimeout = null;
    let slideIntervalMs = 3000;
    let slideDirection = SLIDE_DIRECTION_FORWARD;
    let updateLayoutTimeout = null;
    let inputCaptured = false;
    // options
    let layoutType = LAYOUT_HORIZONTAL;
    let enableAutoSlide = false;
    let enablePaging = false;
    let holdTouch = false;
    let passiveMode = true;
    let startGap = 0;
    let hideOffViewElements = false;
    // status
    let isDragging = false;
    let wasVisible = false;
    let isLazyContainer = false;
    let isFlying = false;
    let actualViewSize = {
        width: 0,
        height: 0
    };
    // timers
    let componentizeInterval = null;
    let componentizeTimeout = null;
    /** @typedef {ZxQuery} */
    let pageList = null;
    // Create a mutation observer instance to watch for child add/remove
    const domObserver = new MutationObserver(function(a, b) {
        // update child list and re-layout
        pageList = cp.view().children();
        updateLayout();
    });

    cp.init = function() {
        let options = cp.options();
        let view = cp.view();
        options.html = false;
        options.css = false;
        enablePaging = (options.enablePaging === true || (view.attr('data-o-paging') === 'true'));
        enableAutoSlide = (options.autoSlide === true || (view.attr('data-o-slide') === 'true'));
        passiveMode = (options.passive !== false && (view.attr('data-o-passive') !== 'false'));
        holdTouch = (options.holdTouch === true || (view.attr('data-o-hold') === 'true'));
        startGap = (options.startGap || view.attr('data-o-startgap'));
        if (options.verticalLayout === true || (view.attr('data-o-layout') === LAYOUT_VERTICAL)) {
            layoutType = LAYOUT_VERTICAL;
        }
        if (options.slideInterval != null) {
            slideIntervalMs = options.slideInterval;
        } else if (view.attr('data-o-slide-interval') != null) {
            slideIntervalMs = parseInt(view.attr('data-o-slide-interval'));
        }
        hideOffViewElements = (options.autohide === true || (view.attr('data-o-autohide') === 'true'));
    };

    cp.create = function() {
        // enable absolute positioning for items in this view
        const view = cp.view().css({
            'position': 'relative',
            'overflow': 'hidden'
        });
        // get child items (pages)
        pageList = view.children();
        // loading of images could change elements size, so layout update might be required
        view.find('img').each(function(i, el) {
            this.one('load', updateLayout);
        });
        // re-arrange view on layout changes
        zuix.$(window)
            .on('resize', function() {
                layoutElements(true);
            }).on('orientationchange', function() {
            layoutElements(true);
        });
        // Options for the observer (which mutations to observe)
        // Register DOM mutation observer callback
        domObserver.observe(view.get(), {
            attributes: false,
            childList: true,
            subtree: true,
            characterData: false
        });
        updateLayout();
        // Set starting page
        setPage(0);
        let tapTimeout = null;
        // gestures handling - load gesture_helper controller
        zuix.load('@lib/controllers/gesture_helper', {
            view: view,
            passive: passiveMode,
            startGap: startGap,
            on: {
                'gesture:touch': function(e, tp) {
                    inputCaptured = false;
                    stopAutoSlide();
                    dragStart();
                    if (holdTouch) tp.cancel();
                },
                'gesture:release': function(e, tp) {
                    dragStop(tp);
                    resetAutoSlide();
                },
                'gesture:tap': function(e, tp) {
                    if (tapTimeout != null) {
                        clearTimeout(tapTimeout);
                    }
                    tapTimeout = setTimeout(function() {
                        handleTap(e, tp);
                    }, 50);
                },
                'gesture:pan': handlePan,
                'gesture:swipe': handleSwipe
            },
            ready: function() {
                layoutElements(true);
            }
        });
        // public component methods
        cp.expose('page', function(number) {
            if (number == null) {
                return parseInt(currentPage);
            } else setPage(number, DEFAULT_PAGE_TRANSITION);
        }).expose('get', function(number) {
            return pageList.eq(number);
        }).expose('slide', function(activate) {
            if (activate === true) {
                resetAutoSlide();
            } else stopAutoSlide();
        }).expose('layout', function(mode) {
            if (mode == null) {
                return layoutType;
            } else if (mode === LAYOUT_VERTICAL) {
                layoutType = LAYOUT_VERTICAL;
            } else layoutType = LAYOUT_HORIZONTAL;
            updateLayout();
        }).expose('refresh', function() {
            layoutElements(true);
        }).expose('next', next)
            .expose('prev', prev)
            .expose('last', last)
            .expose('first', first);
    };

    cp.destroy = function() {
        if (domObserver != null) {
            domObserver.disconnect();
        }
    };

    function updateLayout() {
        if (updateLayoutTimeout != null) {
            clearTimeout(updateLayoutTimeout);
        }
        updateLayoutTimeout = setTimeout(layoutElements, 250);
    }
    function layoutElements(force) {
        if (!force && (isDragging || componentizeInterval != null)) {
            updateLayout();
            return;
        }
        // init elements
        pageList.each(function(i, el) {
            this.css({
                'position': 'absolute',
                'left': 0,
                'top': 0
            });
        });
        // measure
        const viewSize = getSize(cp.view().get());
        if (viewSize.width === 0 || viewSize.height === 0) {
            if (viewSize.height === 0 && cp.view().position().visible) {
                let maxHeight = 0;
                // guess and set view_pager height
                pageList.each(function(i, el) {
                    let size = getSize(el);
                    if (size.height > maxHeight) {
                        maxHeight = size.height;
                    }
                });
                if (viewSize.height < maxHeight) {
                    cp.view().css('height', maxHeight + 'px');
                }
            }
            // cannot measure view, try again later
            updateLayout();
            return;
        }
        actualViewSize = viewSize;
        // position elements
        let offset = 0;
        let isLazy = false;
        pageList.each(function(i, el) {
            let size = getSize(el);
            if (layoutType === LAYOUT_HORIZONTAL) {
                let centerY = (viewSize.height-size.height)/2;
                if (centerY < 0) centerY = 0; // TODO: centering with negative offset was not working
                transition(this, DEFAULT_PAGE_TRANSITION);
                position(this, offset, centerY);
                offset += size.width;
            } else {
                let centerX = (viewSize.width-size.width)/2;
                if (centerX < 0) centerX = 0; // TODO: centering with negative offset was not working
                transition(this, DEFAULT_PAGE_TRANSITION);
                position(this, centerX, offset);
                offset += size.height;
            }
            if (this.attr('data-ui-lazyload') === 'true'
                || this.find('[data-ui-lazyload="true"]').length() > 0) {
                isLazy = true;
            }
        });
        isLazyContainer = isLazy;

        // focus to current page
        setPage(currentPage);
        // start automatic slide
        if (pageList.length() > 1) {
            resetAutoSlide();
        }
    }

    function next() {
        let isLast = false;
        let page = parseInt(currentPage)+1;
        if (page >= pageList.length()) {
            page = pageList.length()-1;
            isLast = true;
        }
        setPage(page, DEFAULT_PAGE_TRANSITION);
        return !isLast;
    }
    function prev() {
        let isFirst = false;
        let page = parseInt(currentPage)-1;
        if (page < 0) {
            page = 0;
            isFirst = true;
        }
        setPage(page, DEFAULT_PAGE_TRANSITION);
        return !isFirst;
    }
    function first() {
        setPage(0, DEFAULT_PAGE_TRANSITION);
    }
    function last() {
        setPage(pageList.length()-1, DEFAULT_PAGE_TRANSITION);
    }

    function slideNext() {
        setPage(parseInt(currentPage) + slideDirection, DEFAULT_PAGE_TRANSITION);
        resetAutoSlide();
    }

    function resetAutoSlide(timeout) {
        stopAutoSlide();
        if (enableAutoSlide === true) {
            const visible = cp.view().position().visible;
            if (visible) {
                if (!wasVisible) {
                    zuix.componentize(cp.view());
                }
                slideTimeout = setTimeout(slideNext, slideIntervalMs);
            } else {
                slideTimeout = setTimeout(resetAutoSlide, 500);
            }
            wasVisible = visible;
        }
    }
    function stopAutoSlide() {
        if (slideTimeout != null) {
            clearTimeout(slideTimeout);
        }
    }

    function getItemIndexAt(x, y) {
        let focusedPage = 0;
        pageList.each(function(i, el) {
            let data = getData(this);
            focusedPage = i;
            const size = getSize(el);
            const rect = {
                x: data.position.x,
                y: data.position.y,
                w: size.width,
                h: size.height
            };
            if ((layoutType === LAYOUT_HORIZONTAL && (rect.x > x || rect.x+rect.w > x))
                || (layoutType === LAYOUT_VERTICAL && (rect.y > y || rect.y+rect.h > y))) {
                return false;
            }
        });
        return focusedPage;
    }

    function focusPageAt(tp, transition) {
        let vp = cp.view().position();
        let page = getItemIndexAt(tp.x-vp.x, tp.y-vp.y);
        setPage(page, transition != null ? transition : DEFAULT_PAGE_TRANSITION);
    }

    function setPage(n, transition) {
        oldPage = currentPage;
        if (n < 0) {
            slideDirection = SLIDE_DIRECTION_FORWARD;
            n = 0;
        } else if (n >= pageList.length()) {
            slideDirection = SLIDE_DIRECTION_BACKWARD;
            n = pageList.length() - 1;
        } else if (n !== currentPage) {
            slideDirection = (currentPage < n) ? SLIDE_DIRECTION_FORWARD : SLIDE_DIRECTION_BACKWARD;
        }
        currentPage = n;
        if (currentPage != oldPage) {
            pageList.eq(currentPage).css('z-index', 1);
            if (oldPage !== -1) {
                pageList.eq(oldPage).css('z-index', 0);
            }
            cp.trigger('page:change', {in: currentPage, out: oldPage});
        }
        const el = pageList.eq(n);
        const data = getData(el);
        const elSize = getSize(el.get());
        const focusPoint = {
            x: (actualViewSize.width - elSize.width) / 2 - data.position.x,
            y: (actualViewSize.height - elSize.height) / 2 - data.position.y
        };
        flyTo(focusPoint, transition);
        resetAutoSlide();
    }

    function flyTo(targetPoint, transition) {
        const spec = getFrameSpec();
        const firstData = getData(pageList.eq(0));
        const lastPage = pageList.eq(pageList.length() - 1);
        const lastData = getData(lastPage);

        pageList.each(function(i, el) {
            const data = getData(this);
            const frameSpec = getFrameSpec();
            data.dragStart = {
                x: frameSpec.marginLeft + data.position.x,
                y: frameSpec.marginTop + data.position.y
            };
        });

        if (layoutType === LAYOUT_HORIZONTAL) {
            let x = targetPoint.x;
            if (firstData.position.x + targetPoint.x > 0) {
                x = -firstData.position.x;
            } else {
                if (lastData.position.x + lastPage.get().offsetWidth + targetPoint.x < actualViewSize.width) {
                    x = -spec.marginLeft*2 + actualViewSize.width - (lastData.position.x + lastPage.get().offsetWidth);
                }
            }
            // check if boundary was adjusted and adjust flying duration accordingly
            if (targetPoint.x-x !== 0 && transition != null) {
                transition = {
                    duration: transition.duration * (x / targetPoint.x),
                    easing: BOUNDARY_HIT_EASING
                };
                if (!isFinite(transition.duration) || transition.duration < 0) {
                    transition.duration = 0.2;
                }
            }
            dragShift(x, 0, transition);
        } else {
            let y = targetPoint.y;
            if (firstData.position.y + targetPoint.y > 0) {
                y = -firstData.position.y;
            } else {
                if (lastData.position.y + lastPage.get().offsetHeight + targetPoint.y < actualViewSize.height) {
                    y = -spec.marginTop*2 + actualViewSize.height - (lastData.position.y + lastPage.get().offsetHeight);
                }
            }
            // check if boundary was adjusted and adjust flying duration accordingly
            if (targetPoint.y-y !== 0 && transition != null) {
                transition = {
                    duration: transition.duration * (y / targetPoint.y),
                    easing: BOUNDARY_HIT_EASING
                };
                if (!isFinite(transition.duration) || transition.duration < 0) {
                    transition.duration = 0.2;
                }
            }
            dragShift(0, y, transition);
        }
        isFlying = true;
    }

    function getSize(el) {
        const rect = el.getBoundingClientRect();
        const width = rect.width || el.offsetWidth;
        const height = el.offsetHeight || rect.height;
        return {width: width, height: height};
    }

    function getData(el) {
        const data = el.get().data = el.get().data || {};
        data.position = data.position || {x: 0, y: 0};
        return data;
    }

    function componentizeStart() {
        if (isLazyContainer) {
            componentizeStop();
            if (componentizeTimeout != null) {
                clearTimeout(componentizeTimeout);
            }
            if (componentizeInterval != null) {
                clearInterval(componentizeInterval);
            }
            componentizeInterval = setInterval(function() {
                if (hideOffViewElements) {
                    pageList.each(function(i, el) {
                        // hide elements if not inside the view_pager
                        const computed = window.getComputedStyle(el, null);
                        const size = {
                            width: parseFloat(computed.width.replace('px', '')),
                            height: parseFloat(computed.height.replace('px', ''))
                        };
                        const x = parseFloat(computed.left.replace('px', ''));
                        const y = parseFloat(computed.top.replace('px', ''));
                        if (size.width > 0 && size.height > 0) {
                            el = zuix.$(el);
                            // check if element is inside the view_pager
                            if (x + size.width < 0 || y + size.height < 0 || x > actualViewSize.width || y > actualViewSize.height) {
                                if (el.visibility() !== 'hidden') {
                                    el.visibility('hidden');
                                }
                            } else if (el.visibility() !== 'visible') {
                                el.visibility('visible');
                            }
                        }
                    });
                }
                zuix.componentize(cp.view());
            }, 10);
        }
    }

    function componentizeStop() {
        if (isLazyContainer && componentizeTimeout == null) {
            clearInterval(componentizeInterval);
        }
    }

    function dragStart() {
        isDragging = true;
        isFlying = false;
        pageList.each(function(i, el) {
            const data = getData(this);
            const frameSpec = getFrameSpec();
            const computed = window.getComputedStyle(el, null);
            data.position.x = parseFloat(computed.left.replace('px', ''));
            data.position.y = parseFloat(computed.top.replace('px', ''));
            this.css('left', data.position.x+'px');
            this.css('top', data.position.y+'px');
            data.dragStart = {x: frameSpec.marginLeft+data.position.x, y: frameSpec.marginTop+data.position.y};
        });
    }

    function getFrameSpec() {
        const spec = {
            w: 0,
            h: 0,
            marginLeft: 0,
            marginTop: 0
        };
        pageList.each(function(i, el) {
            const size = getSize(el);
            spec.w += size.width;
            spec.h += size.height;
        });
        if (layoutType === LAYOUT_HORIZONTAL && spec.w < actualViewSize.width) {
            spec.marginLeft = (actualViewSize.width - spec.w) / 2;
        } else if (layoutType === LAYOUT_VERTICAL && spec.h < actualViewSize.height) {
            spec.marginTop = (actualViewSize.height - spec.h) / 2;
        }
        return spec;
    }

    function dragShift(x, y, tr) {
        if (tr != null) {
            componentizeStart();
            componentizeTimeout = setTimeout(function() {
                componentizeTimeout = null;
                componentizeStop();
            }, tr.duration*1000);
            tr = tr.duration+'s '+tr.easing;
        } else if (isLazyContainer) {
            zuix.componentize(cp.view());
        }
        pageList.each(function(i, el) {
            const data = getData(this);
            transition(this, tr);
            position(this, data.dragStart.x+x, data.dragStart.y+y);
        });
    }

    function dragStop(tp) {
        if (tp != null) {
            tp.done = true;
            // decelerate
            if (!isFlying && ((layoutType === LAYOUT_HORIZONTAL && tp.scrollIntent() === 'horizontal') || (layoutType === LAYOUT_VERTICAL && tp.scrollIntent() === 'vertical'))) {
                decelerate(null, tp);
            }
        }
        componentizeStop();
        isDragging = false;
    }

    // Gesture handling

    function handlePan(e, tp) {
        if (!tp.scrollIntent() || tp.done) {
            return;
        }
        if (inputCaptured
            || ((tp.direction === 'left' || tp.direction === 'right') && layoutType === LAYOUT_HORIZONTAL)
            || ((tp.direction === 'up' || tp.direction === 'down') && layoutType === LAYOUT_VERTICAL)) {
            // capture click event
            if (!inputCaptured && tp.event.touches == null) {
                cp.view().get().addEventListener('click', function(e) {
                    if (inputCaptured) {
                        inputCaptured = false;
                        e.cancelBubble = true;
                        // TODO: 'preventDefault' should not be used with passive listeners
                        e.preventDefault();
                    }
                    // release mouse click capture
                    cp.view().get().removeEventListener('click', this, true);
                }, true);
            }
            inputCaptured = true;
            tp.cancel();
        }
        const spec = getFrameSpec();
        if (layoutType === LAYOUT_HORIZONTAL && tp.scrollIntent() === 'horizontal') {
            dragShift(tp.shiftX-spec.marginLeft, 0);
        } else if (layoutType === LAYOUT_VERTICAL && tp.scrollIntent() === 'vertical') {
            dragShift(0, tp.shiftY-spec.marginTop);
        }
    }

    function handleTap(e, tp) {
        let vp = cp.view().position();
        let page = getItemIndexAt(tp.x-vp.x, tp.y-vp.y);
        cp.trigger('page:tap', page, tp);
        if (enablePaging) focusPageAt(tp);
    }

    function decelerate(e, tp) {
        const minSpeed = 0.01;
        const minStepSpeed = 1.25;
        const accelerationFactor = Math.exp(Math.abs(tp.velocity / (Math.abs(tp.velocity) <= minStepSpeed ? 5 : 2))+1);
        let friction = 0.990 + (accelerationFactor / 1000);
        if (friction > 0.999) {
            friction = 0.999;
        }
        const duration = Math.log(minSpeed / Math.abs(tp.velocity)) / Math.log(friction);
        const decelerateEasing = {
            duration: duration / 1000, // ms to s
            easing: DECELERATE_SCROLL_EASING
        };
        const fly = function(destination, shift) {
            if (enablePaging) {
                decelerateEasing.duration *= 0.5;
                if (layoutType === LAYOUT_HORIZONTAL) {
                    focusPageAt({
                        x: destination.x - shift.x,
                        y: destination.y
                    }, decelerateEasing);
                } else {
                    focusPageAt({
                        x: destination.x,
                        y: destination.y - shift.y
                    }, decelerateEasing);
                }
            } else {
                flyTo(shift, decelerateEasing);
            }
        };
        const flyingDistance = tp.stepSpeed < minStepSpeed ? 0 : accelerationFactor * tp.velocity * (1 - Math.pow(friction, duration + 1)) / (1 - friction);
        const ap = {
            x: flyingDistance,
            y: flyingDistance
        };
        if (willFly(tp) || e == null) fly(tp, ap);
    }

    function willFly(tp) {
        return (!enablePaging || Math.abs(tp.velocity) > 1.25);
    }

    function handleSwipe(e, tp) {
        if (willFly(tp)) {
            return;
        }
        switch (tp.direction) {
            case 'right':
                if (layoutType === LAYOUT_HORIZONTAL) prev();
                break;
            case 'left':
                if (layoutType === LAYOUT_HORIZONTAL) next();
                break;
            case 'down':
                if (layoutType === LAYOUT_VERTICAL) prev();
                break;
            case 'up':
                if (layoutType === LAYOUT_VERTICAL) next();
                break;
        }
    }

    function position(el, x, y) {
        const data = getData(el);
        if (!isNaN(x) && !isNaN(y)) {
            data.position = {'x': x, 'y': y};
            el.css({'left': data.position.x+'px', 'top': data.position.y+'px'});
        }
        return data;
    }

    function transition(el, transition) {
        if (transition == null) {
            transition = 'none';
        }
        el.css({
            '-webkit-transition': transition,
            '-moz-transition': transition,
            '-ms-transition': transition,
            '-o-transition': transition,
            'transition': transition
        });
    }
}},{"componentId":"https:\u002F\u002Fzuixjs.github.io\u002Fzkit\u002Flib\u002Fcontrollers\u002Fgesture_helper","view":"\n    \u003Cdiv class=\"active\" style=\"z-index: 1; transition: none; left: 528px; top: 0px; position: absolute;\"\u003E\n      Top Stories\n    \u003C\u002Fdiv\u003E\n    \u003Cdiv style=\"transition: none; left: 624px; top: 0px; position: absolute;\"\u003E\n      World\n    \u003C\u002Fdiv\u003E\n    \u003Cdiv style=\"transition: none; left: 720px; top: 0px; position: absolute;\"\u003E\n      Europe\n    \u003C\u002Fdiv\u003E\n    \u003Cdiv style=\"transition: none; left: 816px; top: 0px; position: absolute;\"\u003E\n      Travel\n    \u003C\u002Fdiv\u003E\n  ","css":null,"controller":function (cp) {
    const SCROLL_MODE_NONE = 0;
    const SCROLL_MODE_HORIZONTAL = 1;
    const SCROLL_MODE_VERTICAL = 2;
    const GESTURE_TAP_TIMEOUT = 750;

    let scrollMode = SCROLL_MODE_NONE;
    let touchPointer;
    let ignoreSession = false;
    let passiveMode = true;
    let startGap = -1;
    let currentGesture;
    let swipeDirection;
    let speedMeter;
    let mouseButtonDown = false;
    let lastTapTime = new Date().getTime();

    // Math.sign Polyfill
    Math.sign = Math.sign || function(x) {
        return ((x>0)-(x<0))||+x;
    };

    cp.init = function() {
        let view = cp.view();
        const options = cp.options();
        options.html = false;
        options.css = false;
        passiveMode = (options.passive !== false && (view.attr('data-o-passive') !== 'false'));
        startGap = (options.startGap || view.attr('data-o-startgap'));
    };

    cp.create = function() {
        // TODO: should use event "capturing" instead of "bubbling"
        cp.view().on('dragstart', {
            handler: function(e) {
                if (!ignoreSession && !passiveMode) {
                    e.preventDefault();
                }
            },
            passive: passiveMode
        }).on('mousedown', {
            handler: function(e) {
                const targetElement = zuix.$(e.target);
                if (e.which === 1 && targetElement.parent('[class*="no-gesture"]').length() === 0 && e.x > startGap) {
                    mouseButtonDown = true;
                    ignoreSession = false;
                    // targetElement.css('touch-action', 'none');
                    // TODO: add 'cp.options().preventDrag'
                    targetElement.get().draggable = false;
                    touchStart(e, e.x, e.y);
                } else ignoreSession = true;
            },
            passive: passiveMode
        }).on('mousemove', {
            handler: function(e) {
                if (!ignoreSession && mouseButtonDown) {
                    touchMove(e, e.x, e.y);
                }
            },
            passive: passiveMode
        }).on('mouseup', function(e) {
            if (e.which === 1 && !ignoreSession) {
                mouseButtonDown = false;
                touchStop(e);
            }
        }).on('touchstart', {
            handler: function(e) {
                const targetElement = zuix.$(e.target);
                if (targetElement.parent('[class*="no-gesture"]').length() === 0 && e.touches[0].clientX > startGap) {
                    ignoreSession = false;
                    // targetElement.css('touch-action', 'none');
                    targetElement.get().draggable = false;
                    touchStart(e, e.touches[0].clientX, e.touches[0].clientY);
                } else ignoreSession = true;
            },
            passive: passiveMode
        }).on('touchmove', {
            handler: function(e) {
                if (!ignoreSession) {
                    touchMove(e, e.touches[0].clientX, e.touches[0].clientY);
                }
            },
            passive: passiveMode
        }).on('touchend', function(e) {
            if (!ignoreSession) {
                touchStop(e);
            }
        });
    };

    function touchStart(e, x, y) {
        let timestamp = new Date().getTime();
        touchPointer = {
            // original event + cancel method
            event: e,
            cancel: function() {
                touchPointer.event.cancelBubble = true;
                if (!passiveMode) {
                    touchPointer.event.preventDefault();
                }
            },
            // initial touch position
            startX: x,
            startY: y,
            startTime: timestamp,
            // relative movement
            shiftX: 0,
            shiftY: 0,
            endTime: 0,
            // relative movement at every step
            stepX: 0,
            stepY: 0,
            stepTime: timestamp,
            // actual position and speed
            velocity: 0,
            x: x,
            y: y,
            scrollIntent: function() {
                switch (scrollMode) {
                    case SCROLL_MODE_HORIZONTAL:
                        return 'horizontal';
                    case SCROLL_MODE_VERTICAL:
                        return 'vertical';
                }
                return false;
            }
        };
        speedMeter = speedObserver(touchPointer);
        cp.trigger('gesture:touch', touchPointer);
    }
    function touchMove(e, x, y) {
        if (touchPointer != null) {
            touchPointer.event = e;
            touchPointer.x = x;
            touchPointer.y = y;
            touchPointer.shiftX = (x - touchPointer.startX);
            touchPointer.shiftY = (y - touchPointer.startY);
            touchPointer.endTime = new Date().getTime();
            // detect actual gesture
            let gesture = detectGesture();
            if (gesture != null && currentGesture !== false) {
                if (swipeDirection != null && swipeDirection !== touchPointer.direction) {
                    // stop gesture detection if not coherent
                    currentGesture = false;
                    swipeDirection = 'cancel';
                } else {
                    currentGesture = gesture;
                    swipeDirection = touchPointer.direction;
                }
            }
            cp.trigger('gesture:pan', touchPointer);
        }
    }

    function touchStop(e) {
        if (touchPointer != null) {
            speedMeter.update();
            touchPointer.event = e;
            if (currentGesture == null) {
                currentGesture = detectGesture();
            }
            if (currentGesture != null && currentGesture !== false) {
                cp.trigger(currentGesture, touchPointer);
            }
        }
        cp.trigger('gesture:release', touchPointer);
        scrollMode = SCROLL_MODE_NONE;
        swipeDirection = null;
        currentGesture = null;
        touchPointer = null;
    }

    function detectGesture() {
        let gesture = null;
        // update touchPointer.velocity data
        speedMeter.update();
        // update tap gesture and swipe direction
        const minStepDistance = 2; // <--- !!! this should not be greater than 2 for best performance
        const angle = Math.atan2(touchPointer.shiftY-touchPointer.stepY, touchPointer.shiftX-touchPointer.stepX) * 180 / Math.PI;
        if ((touchPointer.shiftX) === 0 && (touchPointer.shiftY) === 0 && touchPointer.startTime > lastTapTime+100 && touchPointer.stepTime < GESTURE_TAP_TIMEOUT) {
            // gesture TAP
            lastTapTime = new Date().getTime();
            gesture = 'gesture:tap';
        } else if ((scrollMode === SCROLL_MODE_NONE || scrollMode === SCROLL_MODE_HORIZONTAL)
            && touchPointer.stepDistance > minStepDistance && ((angle >= 135 && angle <= 180) || (angle >= -180 && angle <= -135))) {
            // gesture swipe RIGHT
            touchPointer.direction = 'left';
            gesture = 'gesture:swipe';
            scrollMode = SCROLL_MODE_HORIZONTAL;
        } else if ((scrollMode === SCROLL_MODE_NONE || scrollMode === SCROLL_MODE_HORIZONTAL)
            && touchPointer.stepDistance > minStepDistance && ((angle >= 0 && angle <= 45) || (angle >= -45 && angle < 0))) {
            // gesture swipe LEFT
            touchPointer.direction = 'right';
            gesture = 'gesture:swipe';
            scrollMode = SCROLL_MODE_HORIZONTAL;
        } else if ((scrollMode === SCROLL_MODE_NONE || scrollMode === SCROLL_MODE_VERTICAL)
            && touchPointer.stepDistance > minStepDistance && (angle > 45 && angle < 135)) {
            // gesture swipe UP
            touchPointer.direction = 'down';
            gesture = 'gesture:swipe';
            scrollMode = SCROLL_MODE_VERTICAL;
        } else if ((scrollMode === SCROLL_MODE_NONE || scrollMode === SCROLL_MODE_VERTICAL)
            && touchPointer.stepDistance > minStepDistance && (angle > -135 && angle < -45)) {
            // gesture swipe DOWN
            touchPointer.direction = 'up';
            gesture = 'gesture:swipe';
            scrollMode = SCROLL_MODE_VERTICAL;
        }
        // reset touch step data
        if (touchPointer.stepDistance > minStepDistance) {
            speedMeter.step();
        }
        return gesture;
    }

    function speedObserver(tp) {
        let direction;
        let startData = {
            time: 0,
            x: 0, y: 0
        };
        let stopData = {
            time: 0,
            x: 0, y: 0
        };
        let step = function() {
            tp.stepTime = tp.endTime;
            tp.stepX = tp.shiftX;
            tp.stepY = tp.shiftY;
            tp.stepSpeed = 0;
            tp.stepDistance = 0;
        };
        let reset = function() {
            // direction changed: reset
            direction = tp.direction;
            startData.time = new Date().getTime();
            startData.x = tp.x;
            startData.y = tp.y;
            tp.velocity = 0;
            tp.distance = 0;
            step();
        };
        reset();
        return {
            update: function() {
                stopData.time = new Date().getTime();
                stopData.x = tp.x;
                stopData.y = tp.y;
                if (direction != null && direction !== tp.direction) {
                    reset();
                    return;
                } else if (direction == null && tp.direction !== direction) {
                    direction = tp.direction;
                }
                const elapsedTime = stopData.time - startData.time;
                let l = {x: (stopData.x - startData.x), y: (stopData.y - startData.y)};
                const d = Math.sqrt(l.x*l.x + l.y*l.y);
                tp.distance = d;
                // movement speed in px/ms
                let speed = (d / elapsedTime);
                // add the direction info
                tp.velocity = (tp.direction === 'left' || tp.direction === 'up') ? -speed : speed;
                // update "step" speed data
                tp.stepTime = (tp.endTime-tp.stepTime);
                l = {x: (tp.shiftX-tp.stepX), y: (tp.shiftY-tp.stepY)};
                tp.stepDistance = Math.sqrt(l.x*l.x+l.y*l.y);
                tp.stepSpeed = (tp.stepDistance / tp.stepTime);
            },
            step: step
        };
    }
}},{"componentId":"https:\u002F\u002Fzuixjs.github.io\u002Fzkit\u002Flib\u002Fcomponents\u002Fcontext_menu","controller":function (cp){
    let menu;
    let view;

    cp.create = function() {
        menu = cp.field('menu');
        menu.css('bottom', -(menu.position().rect.height)+'px');
        view = cp.view();
        view.css('opacity', 0)
            .hide()
            .on('click', function() {
                hideMenu();
            })
            .on('keydown', function(evt) {
                evt = evt || window.event;
                if (evt.keyCode === 27) {
                    hideMenu();
                }
            });
        zuix.load('@lib/controllers/gesture_helper', {
            view: view,
            on: {
                'gesture:pan': function(e, tp) {
                    if (!menu.hasClass('no-transition')) {
                        menu.addClass('no-transition');
                    }
                    if (tp.shiftY > 0) {
                        menu.css('bottom', -tp.shiftY + 'px');
                    }
                },
                'gesture:release': function(e, tp) {
                    menu.removeClass('no-transition');
                    if (tp.velocity <= 0 && tp.direction === 'up') {
                        menu.css('bottom', 0);
                    } else if (tp.direction === 'down') {
                        hideMenu();
                    }
                }
            }
        });
        cp.expose('show', showMenu);
        cp.expose('hide', hideMenu);
    };

    function showMenu() {
        view.show();
        // animation will not work without this delay =/
        setTimeout(function() {
            view.css('opacity', 1);
            menu.css('bottom', 0)
                .get().focus();
        }, 100);
        cp.trigger('open');
    }

    function hideMenu() {
        view.one('transitionend', function() {
                this.hide();
            })
            .css('opacity', 0);
        menu.css('bottom', -(menu.position().rect.height)+'px');
        cp.trigger('close');
    }
},"css":". {\n    position: fixed;\n    bottom:0;\n    left:0;\n    right: 0;\n    top: 0;\n    -ms-touch-action: none;\n    touch-action: none;\n    background: rgba(0,0,0,0.5);\n    z-index: 200;\n    -webkit-transition: opacity 0.25s ease-in-out;\n    -moz-transition: opacity 0.25s ease-in-out;\n    -ms-transition: opacity 0.25s ease-in-out;\n    -o-transition: opacity 0.25s ease-in-out;\n    transition: opacity 0.25s ease-in-out;\n}\n.menu {\n    outline: none !important;\n    margin-left: auto;\n    margin-right: auto;\n    left: 50%;\n    transform: translateX(-50%);\n    position: absolute;\n    width: 100%;\n    max-width: 420px;\n    background: white;\n    border: solid 1px rgba(0,0,0,0.1);\n    border-radius: 16px 16px 0 0;\n    box-shadow: 0 -5px 5px -5px #333;\n    -webkit-transition: bottom 0.25s ease-in-out;\n    -moz-transition: bottom 0.25s ease-in-out;\n    -ms-transition: bottom 0.25s ease-in-out;\n    -o-transition: bottom 0.25s ease-in-out;\n    transition: bottom 0.25s ease-in-out;\n}\nbutton {\n    width: 100%;\n    height:48px;\n    padding: 16px;\n    background: none;\n    border: none;\n}\nbutton span {\n    font-family: sans-serif, Helvetica;\n    font-size: 120%;\n    margin-left: 24px;\n}\nbutton i {\n    color: gray;\n    font-size: 140%;\n    margin-left: 8px;\n}\nbutton:hover {\n    background: rgba(0,0,0,0.1);\n}\n.no-transition {\n    -webkit-transition: none;\n    -moz-transition: none;\n    -ms-transition: none;\n    -o-transition: none;\n    transition: none;\n}\n","view":"\u003Cdiv data-ui-field=\"menu\" class=\"menu\" tabindex=\"0\"\u003E\u003C\u002Fdiv\u003E\n"},{"componentId":"https:\u002F\u002Fzuixjs.github.io\u002Fzkit\u002Flib\u002Fcontrollers\u002Fheader_auto_hide","controller":function (cp) {
    let headerBar;
    let footerBar;
    let headerHeight = 0;
    let footerHeight = 0;
    cp.init = function() {
        cp.options().css = false;
        cp.options().html = false;
    };
    cp.create = function() {
        // options parsing
        let header = cp.options().header || cp.view().attr('data-o-header');
        if (header != null) {
            headerBar = zuix.field(header);
        }
        let footer = cp.options().footer || cp.view().attr('data-o-footer');
        if (footer != null) {
            footerBar = zuix.field(footer);
        }
        let height = cp.options().height || cp.view().attr('data-o-height');
        if (height != null && !isNaN(height)) {
            headerHeight = footerHeight = parseInt(height);
            addHeaderStyle(); addFooterStyle();
        }
        // TODO: this can be optimized (do not replace CSS, skip if already exists)
        const startTime = new Date().getTime();
        zuix.load('@lib/controllers/scroll_helper', {
            view: cp.view(),
            on: {
                'scroll:change': function(e, data) {
                    if (data.event === 'scroll' && (new Date().getTime()-startTime > 1000)) {
                        if (data.info.shift.y < 0) {
                            // scrolling up
                            hideBars();
                        } else if (data.info.shift.y > 0) {
                            // scrolling down
                            showBars();
                        }
                    }
                    cp.trigger('page:scroll', data);
                }
            }
        });
        cp.expose('show', showBars)
            .expose('hide', hideBars);
    };
    function showBars() {
        if (headerBar != null && headerBar.hasClass('header-collapse')) {
            headerBar.removeClass('header-collapse')
                .addClass('header-expand');
        }
        if (footerBar != null && footerBar.hasClass('footer-collapse')) {
            footerBar.removeClass('footer-collapse')
                .addClass('footer-expand');
        }
    }
    function hideBars() {
        if (headerBar != null && !headerBar.hasClass('header-collapse')) {
            if (headerHeight === 0) {
                headerHeight = headerBar.position().rect.height;
                if (headerHeight > 0) {
                    addHeaderStyle();
                }
            }
            headerBar.removeClass('header-expand')
                .addClass('header-collapse');
        }
        if (footerBar != null && !footerBar.hasClass('footer-collapse')) {
            if (footerHeight === 0) {
                footerHeight = footerBar.position().rect.height;
                if (headerHeight > 0) {
                    addFooterStyle();
                }
            }
            footerBar.removeClass('footer-expand')
                .addClass('footer-collapse');
        }
    }

    function addHeaderStyle() {
        zuix.$.appendCss('\n' +
            '/* Header bar shrink/expand */\n' +
            '@keyframes header-collapse-anim {\n' +
            '  from { top: 0; }\n' +
            '  to { top: -'+headerHeight+'px; }\n' +
            '}\n' +
            '@keyframes header-expand-anim {\n' +
            '  from { top: -'+headerHeight+'px; }\n' +
            '  to { top: 0; }\n' +
            '}\n' +
            '.header-collapse {\n' +
            '  animation-fill-mode: forwards;\n' +
            '  animation-name: header-collapse-anim;\n' +
            '  animation-duration: 0.5s;\n' +
            '  top: -'+headerHeight+'px;\n' +
            '}\n' +
            '.header-expand {\n' +
            '  animation-fill-mode: forwards;\n' +
            '  animation-name: header-expand-anim;\n' +
            '  animation-duration: 0.5s;\n' +
            '  top: 0px;\n' +
            '}\n', null, 'onscroll_header_hide_show');
    }
    function addFooterStyle() {
        zuix.$.appendCss('\n' +
            '/* Footer bar shrink/expand */\n' +
            '@keyframes footer-collapse-anim {\n' +
            '  from { bottom: 0; }\n' +
            '  to { bottom: -'+footerHeight+'px; }\n' +
            '}\n' +
            '@keyframes footer-expand-anim {\n' +
            '  from { bottom: -'+footerHeight+'px; }\n' +
            '  to { bottom: 0; }\n' +
            '}\n' +
            '.footer-collapse {\n' +
            '  animation-fill-mode: forwards;\n' +
            '  animation-name: footer-collapse-anim;\n' +
            '  animation-duration: 0.5s;\n' +
            '  bottom: -'+footerHeight+'px;\n' +
            '}\n' +
            '.footer-expand {\n' +
            '  animation-fill-mode: forwards;\n' +
            '  animation-name: footer-expand-anim;\n' +
            '  animation-duration: 0.5s;\n' +
            '  bottom: 0;\n' +
            '}\n', null, 'zkit_onscroll_hide_show');
    }
}},{"componentId":"https:\u002F\u002Fzuixjs.github.io\u002Fzkit\u002Flib\u002Fcontrollers\u002Fscroll_helper","view":"\n\n        \u003Cdiv data-ui-load=\"pages\u002Fhome\u002Fitems_list\" data-o-rss=\"http:\u002F\u002Frss.cnn.com\u002Frss\u002Fedition.rss\" data-ui-loaded=\"false\"\u003E\u003C\u002Fdiv\u003E\n\n    ","css":null,"controller":function (cp) {
    const scrollInfo = {
        timestamp: 0,
        size: {
            width: 0,
            height: 0
        },
        viewport: {
            x: 0,
            y: 0,
            width: 0,
            height: 0
        }
    };
    let updateTimeout;
    let watchList;
    let watchCallback;
    let scrollToEndTs = 0;

    cp.init = function() {
        cp.options().html = false;
        cp.options().css = false;
    };

    cp.create = function() {
        if (cp.view().get() === document.body) {
            if (cp.options().throttle > 0) {
                window.onscroll = throttle(scrollCheck, cp.options().throttle);
            } else {
                window.onscroll = scrollCheck;
            }
        } else {
            if (cp.options().throttle > 0) {
                cp.view().on('scroll', throttle(scrollCheck, cp.options().throttle));
            } else {
                cp.view().on('scroll', scrollCheck);
            }
        }
        cp.expose('watch', function(filter, callback) {
            setWatchList(filter, callback);
            return cp.context;
        });
        cp.expose('scrollStart', function(duration) {
            if (duration == null) duration = -1;
            scrollTo(0, duration);
            return cp.context;
        }).expose('scrollEnd', function(duration) {
            if (duration == null) duration = -1;
            scrollTo(scrollInfo.size.height, duration);
            return cp.context;
        }).expose('scrollTo', function(to, duration) {
            if (duration == null) duration = -1;
            scrollTo(to, duration);
            return cp.context;
        }).expose('info', function() {
            return scrollInfo;
        });
        // TODO: that's a temp hack to force measure at start
        scrollTo(5, -1);
        scrollTo(0, 200);
    };

    let frameSkipTs;
    function scrollCheck() {
        // TODO: implement code for horizontal scroll as well

        if (updateTimeout != null) {
            clearTimeout(updateTimeout);
        }
        const now = new Date().getTime();
        if (now - scrollInfo.timestamp > 100) {
            updateScrollInfo();
        } else {
            updateTimeout = setTimeout(function() {
                updateScrollInfo();
            }, 99);
        }

        if (now < scrollToEndTs && now-frameSkipTs < 66) {
            return;
        }
        frameSkipTs = now;

        const scrollable = cp.view().get();
        const visibleClass = 'scroll-helper-visible';
        if (watchList != null && watchCallback != null) {
            watchList.each(function(i, el) {

                // TODO: replace this code using the new "zuix.$(el).position()" method

                const position = this.position();

                let visible = false;
                let tolerance = 0;
                if (el.offsetParent === null) {
                    // not attached yet.
                    return false;
                }
                if (tolerance == null) tolerance = 0;

                const r1 = {
                    left: 0,
                    top: 0,
                    right: scrollInfo.viewport.width,
                    bottom: scrollInfo.viewport.height,
                    width: scrollInfo.viewport.width,
                    height: scrollInfo.viewport.height
                };
                let r2 = el.getBoundingClientRect();
                let parent = el.offsetParent;
                while (parent !== null && parent !== scrollable) {
                    const pr = parent.getBoundingClientRect();
                    r2 = {
                        left: r2.left + pr.left,
                        top: r2.top + pr.top,
                        right: r2.right + pr.left,
                        bottom: r2.bottom + pr.top,
                        width: r2.width,
                        height: r2.height
                    };
                    parent = parent.offsetParent;
                }

                visible = !(r2.left > r1.right-tolerance ||
                    r2.right < r1.left+tolerance ||
                    r2.top > r1.bottom-tolerance ||
                    r2.bottom < r1.top+tolerance);

                position.frame = {
                    dx: (r2.left+(r2.width/2)-r1.left)/r1.width,
                    dy: (r2.top+(r2.height/2)-r1.top)/r1.height
                };
                position.visible = visible;

                if (!visible && this.hasClass(visibleClass)) {
                    this.removeClass(visibleClass);
                    position.event = 'exit';
                } else if (!visible) {
                    position.event = 'off-scroll';
                } else if (visible) {
                    if (!this.hasClass(visibleClass)) {
                        position.event = 'enter';
                        this.addClass(visibleClass);
                    } else position.event = 'scroll';
                } else return;
                watchCallback(this, position);
            });
        }
    }

    function setWatchList(filter, callback) {
        if (filter != null) {
            watchList = cp.view(filter);
            watchCallback = callback;
        } else {
            watchList = null;
            watchCallback = null;
        }
    }

    function updateScrollInfo() {
        const scrollable = cp.view().get();
        const rect = scrollable.getBoundingClientRect();
        const vp = {
            top: rect.top,
            right: rect.right,
            bottom: rect.bottom,
            left: rect.left,
            width: rect.width,
            height: rect.height,
            x: rect.x,
            y: rect.y
        };
        vp.y = -cp.view().get().scrollTop || (vp.y ? vp.y : 0);
        vp.height = cp.view().get().scrollHeight || (vp.height ? vp.height : 0);
        scrollInfo.size.width = vp.width;
        scrollInfo.size.height = vp.height;
        if (scrollable === document.body) {
            scrollInfo.size.width = document.body.offsetWidth;
            scrollInfo.size.height = document.body.offsetHeight;
            scrollInfo.viewport.width = document.documentElement.clientWidth || scrollInfo.size.width;
            scrollInfo.viewport.height = document.documentElement.clientHeight || scrollInfo.size.height;
        } else {
            scrollInfo.viewport.width = scrollable.offsetWidth;
            scrollInfo.viewport.height = scrollable.offsetHeight;
        }
        scrollInfo.timestamp = new Date().getTime();
        scrollInfo.shift = {
            x: vp.x - scrollInfo.viewport.x,
            y: vp.y - scrollInfo.viewport.y
        };
        scrollInfo.viewport.x = vp.x;
        scrollInfo.viewport.y = vp.y;
        const endScroll = scrollInfo.size.height+vp.y-scrollInfo.viewport.height;
        if ((endScroll === 0 || vp.y === 0)) {
            cp.trigger('scroll:change', {event: vp.y === 0 ? 'hit-top' : 'hit-bottom', info: scrollInfo});
        } else {
            cp.trigger('scroll:change', {event: 'scroll', info: scrollInfo});
        }
    }

    function scrollTo(to, duration) {
        if (to instanceof Element || to instanceof zuix.$.ZxQuery) {
            to = zuix.$(to).position().y - scrollInfo.viewport.y;
        }
        if (duration === -1) {
            return setScroll(to);
        }
        const currentTs = Date.now();
        if (duration != null) {
            scrollToEndTs = currentTs + duration;
        }
        duration = scrollToEndTs-currentTs;

        const el = cp.view().get();
        let scrollTop = 0;
        if (el === document.body) {
            scrollTop = (window.pageYOffset !== undefined)
                ? window.pageYOffset
                : (document.documentElement || document.body.parentNode || document.body).scrollTop;
        } else scrollTop = el.scrollTop;

        const difference = to - scrollTop;
        if (duration <= 0 || difference === 0) {
            setScroll(to);
            scrollCheck();
            return;
        }

        const offset = scrollTop + (difference / duration * 33);
        requestAnimationFrame(function() {
            setScroll(offset);
            scrollTo(to);
        });
    }

    function setScroll(to) {
        const el = cp.view().get();
        if (el === document.body) {
            document.documentElement.scrollTop = to;
            document.body.scrollTop = to;
        } else el.scrollTop = to;
    }

    function throttle(func, limit) {
        let lastFunc = void 0;
        let lastRan = void 0;
        return function() {
            const context = this;
            const args = arguments;
            if (!lastRan) {
                func.apply(context, args);
                lastRan = Date.now();
            } else {
                clearTimeout(lastFunc);
                lastFunc = setTimeout(function() {
                    if (Date.now() - lastRan >= limit) {
                        func.apply(context, args);
                        lastRan = Date.now();
                    }
                }, limit - (Date.now() - lastRan));
            }
        };
    }
}},{"componentId":"pages\u002Fhome\u002Fitems_list","view":"\u003Cdiv data-ui-field=\"list\" self=\"size-xxlarge center\" layout=\"rows stretch-center\" class=\"list\"\u003E\u003C\u002Fdiv\u003E\n","css":".list {\n  margin-top: 96px;\n  margin-bottom: 206px;\n}\n\n.card-wrapper {\n  margin: 0;\n  padding:8px;\n  max-width: 100%;\n  \u002F* min-height: 100px; this is causing strange behavior on mobile, like delayed loading?!? *\u002F\n  overflow: hidden;\n  font-family: Helvetica, sans-serif !important;\n}\n\n.info {\n  margin-left:4px;\n  margin-right:4px;\n}\n\n.card {\n  width: 100%;\n  position: relative;\n  max-width: 640px;\n  min-height: 200px;\n  padding: 12px;\n  padding-bottom: 24px;\n}\n.card i {\n  color: gray;\n  font-size: 200%;\n}\n.cover-wrapper {\n  cursor: pointer;\n  width: 100%;\n  border-radius: 12px;\n  padding-top: 75%;\n  position: relative;\n  overflow: hidden;\n  background-size: cover;\n  background: #f2f2f2 no-repeat center center;\n}\n.summary {\n  width: 100%;\n}\n.options {\n  color: dimgrey;\n}\n.options span {\n  font-size: 80%;\n}\n.options button {\n  width: 48px;\n  height: 48px;\n  padding-top: 4px;\n  background: rgba(50,50,50,0.01);\n  border: none;\n  border-radius: 24px;\n}\n.options button:hover {\n  background: rgba(0,0,0,0.1);\n}\n","controller":function (cp) {
  const zx = zuix; // shorthand
  let itemsList;

  cp.create = function() {
    let url = cp.view().attr('data-o-rss');
    // Use a proxy to prevent CORS policy restrictions errors
    url = '//cors-anywhere.herokuapp.com/'+url;
    fetchList(url);
  };

  function refresh() {
    const list = cp.field('list');
    if (itemsList != null) {
      zx.$.each(itemsList, function(i, item) {
        const options = {
          lazyLoad: true,
          model: item
        };
        let el;
        if (i < 5) {
          // different layout for first 4 items (bigger)
          el = zx.createComponent('pages/home/items_list/item', options).container();
          // 2 columns layout
          if (i < 2) {
            el.setAttribute('self', 'size-1of2 lg-full md-full sm-full');
          } else {
            el.setAttribute('self', 'size-1of3 lg-half md-half sm-full');
          }
          el.setAttribute('class', 'card-wrapper'); // <-- will this work?
        } else {
          // "mini" layout for subsequent items
          el = zx.createComponent('pages/home/items_list/item_mini', options).container();
          // 4 columns layout
          el.setAttribute('self', 'size-1of4 lg-half md-half sm-full');
          el.setAttribute('class', 'card-wrapper mini'); // <-- will this work?
        }
        // center the list on wide screens
        el.setAttribute('layout', 'column stretch-center');
        list.append(el);
      });
      zuix.componentize();
    }
  }

  // Download RSS feed
  function fetchList(rssUrl) {
    // CORS proxy https://cors-anywhere.herokuapp.com/
    zx.$.ajax({
      url: rssUrl,
      success: function(res) {
        itemsList = parseRss(res);
        refresh();
      },
      error: function(err) {
        // TODO: handle error
      }
    });
  }

  // Parse RSS feed and create a JSON object out of it
  function parseRss(rssText) {
    const items = [];
    const parser = new DOMParser();
    const doc = parser.parseFromString(rssText, "text/xml");
    let d = zx.$(doc);
    d.find('channel > item').each(function(i, el){
      const title = getText(this.find('title'));
      const description = getText(this.find('description'));
      const pubDate = getText(this.find('pubDate'));
      const link = getText(this.find('link'));
      const imageList = this.find('[medium="image"]');
      if (title !== '') {
        const images = [];
        // parse images to a json list
        imageList.each(function(i, el) {
          images.push({
            url: this.attr('url'),
            width: this.attr('width'),
            height: this.attr('height')
          });
        });
        let cover;
        if (i < 5 && images[3] != null) cover = images[3].url;
        else if (i > 3 && images[4] != null) cover = images[4].url;
        const date = pubDate; // TODO: format date
        items.push({
          title,
          link,
          cover,
          date,
          images
        });
      }
    });
    return items;
  }

  function getText(node) {
    let text;
    // if node is ZxQuery, then get underlying HTMLElement
    if (node.length() > 0) node = node.get();
    if (node != null && node.firstChild != null) {
      // get rid of CDATA wrapper eventually
      text = node.firstChild.nodeValue;
    } else if (node != null) {
      // get value as is
      text = node.innerHTML;
    }
    return text;
  }
},"css_applied":true}]);