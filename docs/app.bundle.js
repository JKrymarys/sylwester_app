zuix.bundle(
/*
 * zUIx Application Bundle
 * 
 * app.bundle.js generated by *zuix-bundler*
 *   on 2019-12-28T13:12:16.154Z
 * 
 * Resource list (11):
 * 
 * - [js] 
 *   ./service-worker.js (_res/script/script-605580544)
 * 
 * - [css] 
 *   ./index.css (_res/style/style-1784725062)
 * 
 * - [html] [css] [js] 
 *   layout/header
 * 
 * - [css] 
 *   //zuixjs.github.io/zkit/css/flex-layout-attribute.min.css (_res/style/style--1101994688)
 * 
 * - [html] [css] [js] 
 *   layout/footer
 * 
 * - [html] [css] [js] 
 *   pages/home
 * 
 * - [html] [css] [js] 
 *   pages/map
 * 
 * - [html] [css] [js] 
 *   pages/drinks
 * 
 * - [html] [css] [js] 
 *   pages/about
 * 
 * - [js] 
 *   https://zuixjs.github.io/zkit/lib/controllers/view_pager
 * 
 * - [html] [js] 
 *   https://zuixjs.github.io/zkit/lib/controllers/gesture_helper
 * 
 * 
*/

[{"componentId":"_res\u002Fscript\u002Fscript-605580544","view":null,"css":null,"controller":"if ('serviceWorker' in navigator) {\n    const p = navigator.serviceWorker\n        .register('.\u002Fsw.js')\n        .then(reg =\u003E console.log('PWA service-worker ready.', reg))\n        .catch(err =\u003E console.error('Could not load service-worker.', err));\n}\n","using":".\u002Fservice-worker.js"},{"componentId":"_res\u002Fstyle\u002Fstyle-1784725062","view":null,"css":"\u002F* CSS files add styling rules to your content *\u002F\n\nbody {\n    font-family: \"Benton Sans\", \"Helvetica Neue\", helvetica, arial, sans-serif;\n    font-size: 16px;\n    margin: 0; padding: 0;\n    background: black;\n    -webkit-user-select:none;\n    -moz-user-select:none;\n    -ms-user-select:none;\n    user-select:none;\n    overscroll-behavior-y: contain;\n}\n\n.drawer {\n    background: black;\n}\n","controller":null,"using":".\u002Findex.css"},{"componentId":"layout\u002Fheader","view":"\u003Cdiv class=\"header\"\u003E\n    \u003C!-- \u003Cdiv class=\"profile pulse\"\u003E\n        \u003C!-- \u003Cimg alt=\"Profile Icon\" src=\"images\u002Fprofile_icon.png\"\u003E --\u003E\n\u003C\u002Fdiv\u003E --\u003E\n\u003Cdiv data-ui-field=\"header-box\" layout=\"row\"\u003E\n    \u003Cdiv class=\"title\"\u003E\n        Home\n    \u003C\u002Fdiv\u003E\n    \u003Cdiv class=\"title\"\u003E\n        Dojazd\n    \u003C\u002Fdiv\u003E\n    \u003Cdiv class=\"title\"\u003E\n        Drineczki\n    \u003C\u002Fdiv\u003E\n    \u003Cdiv class=\"title\"\u003E\n        Inne\n    \u003C\u002Fdiv\u003E\n\u003C\u002Fdiv\u003E\n\u003C\u002Fdiv\u003E\n\u003Cdiv data-ui-field=\"header-tools\"\u003E\n    \u003Cdiv class=\"topics\" data-ui-load=\"@lib\u002Fcontrollers\u002Fview_pager\" data-ui-options=\"options.topicIndicator\"\u003E\n        \u003Cdiv\u003E\n            Top Stories\n        \u003C\u002Fdiv\u003E\n        \u003Cdiv\u003E\n            World\n        \u003C\u002Fdiv\u003E\n        \u003Cdiv\u003E\n            Europe\n        \u003C\u002Fdiv\u003E\n        \u003Cdiv\u003E\n            Travel\n        \u003C\u002Fdiv\u003E\n    \u003C\u002Fdiv\u003E\n\u003C\u002Fdiv\u003E","css":". {\n    position: fixed;\n    top: 0;\n    left: 0;\n    right: 0;\n    height: auto;\n    background: rgba(0, 0, 0, 0.97);\n    border-bottom: solid 1px rgba(0, 0, 0, 0.25);\n    box-shadow: 0 6px 2px -2px rgba(100, 100, 100, 0.25);\n    z-index: 100;\n}\n\n.header {\n    height: 56px;\n    max-height: 56px;\n}\n\n.title {\n    position: absolute;\n    color: orange;\n    top: 12px;\n    left: 80px;\n    font-size: 180%;\n}\n\n.profile {\n    position: absolute;\n    left: 20px;\n    top: 8px;\n    width: 42px;\n    height: 42px;\n    background: #f5f8fa;\n    border-radius: 50%;\n    border: solid 1px #00aced;\n    overflow: hidden;\n    cursor: pointer;\n}\n\n.profile img {\n    margin-left: -2px;\n    height: 44px;\n}\n\n.topics {\n    width: 100%;\n    height: 40px;\n}\n\n.topics div {\n    font-size: 16px;\n    height: 36px;\n    min-width: 96px;\n    text-align: center;\n    vertical-align: middle;\n    line-height: 36px;\n    border-bottom: solid 4px transparent;\n    cursor: pointer;\n}\n\n.active {\n    color: initial;\n    font-weight: bold;\n    border-bottom: solid 4px #00aced !important;\n}\n\n[data-ui-field=\"header-box\"] {\n    padding-left: 72px;\n    padding-right: 16px;\n    height: 100%;\n}\n\n\n\u002F* Pulse Animation from https:\u002F\u002Fcodepen.io\u002Folam\u002Fpen\u002Fzcqea *\u002F\n\n.pulse {\n    box-shadow: 0 0 0 rgba(204, 169, 44, 0.4);\n    animation: pulse 2s infinite;\n}\n\n.pulse:hover {\n    animation: none;\n}\n\n@-webkit-keyframes pulse {\n    0% {\n        -webkit-box-shadow: 0 0 0 0 rgba(204, 169, 44, 0.4);\n    }\n    70% {\n        -webkit-box-shadow: 0 0 0 10px rgba(204, 169, 44, 0);\n    }\n    100% {\n        -webkit-box-shadow: 0 0 0 0 rgba(204, 169, 44, 0);\n    }\n}\n\n@keyframes pulse {\n    0% {\n        -moz-box-shadow: 0 0 0 0 rgba(204, 169, 44, 0.4);\n        box-shadow: 0 0 0 0 rgba(204, 169, 44, 0.4);\n    }\n    70% {\n        -moz-box-shadow: 0 0 0 10px rgba(204, 169, 44, 0);\n        box-shadow: 0 0 0 10px rgba(204, 169, 44, 0);\n    }\n    100% {\n        -moz-box-shadow: 0 0 0 0 rgba(204, 169, 44, 0);\n        box-shadow: 0 0 0 0 rgba(204, 169, 44, 0);\n    }\n}","controller":function(){}},{"componentId":"_res\u002Fstyle\u002Fstyle--1101994688","view":null,"css":"\u002F**\n * Flex layout attribute\n * HTML layout helper based on CSS flexbox specification.\n * \n * VERSION: v1.0.3\n * DATE:    2016-06-21\n * URL:     http:\u002F\u002Fprogressivered.com\u002Ffla\u002F\n * AUTHOR:  Stefan Kovac | stef@progressivered.com | http:\u002F\u002Fprogressivered.com\u002F\n * LICENSE: MIT \n *\u002F\n \nhtml{box-sizing:border-box}*,:after,:before{box-sizing:inherit}[layout]{display:-ms-flexbox;display:flex}[layout*=column],[layout*=row]{width:100%;max-width:100%}[layout^=row]{-ms-flex-direction:row;flex-direction:row}[layout^=column]{-ms-flex-direction:column;flex-direction:column}[layout*=row][layout*=reverse]{-ms-flex-direction:row-reverse;flex-direction:row-reverse}[layout*=column][layout*=reverse]{-ms-flex-direction:column-reverse;flex-direction:column-reverse}[layout*=columns],[layout*=rows]{-ms-flex-wrap:wrap;flex-wrap:wrap}[layout=none]{-ms-flex:none;flex:none}[layout*=column][layout*=top-],[layout*=row][layout*=-left]{-ms-flex-pack:start;justify-content:flex-start}[layout*=column][layout*=center-],[layout*=row][layout*=-center],[layout~=centered]{-ms-flex-pack:center;justify-content:center}[layout*=column][layout*=bottom-],[layout*=row][layout*=-right]{-ms-flex-pack:end;justify-content:flex-end}[layout*=column][layout*=spread-],[layout*=row][layout*=-spread]{-ms-flex-pack:distribute;justify-content:space-around}[layout*=column][layout*=justify-],[layout*=row][layout*=-justify]{-ms-flex-pack:justify;justify-content:space-between}[layout*=column][layout*=-left],[layout*=row][layout*=top-]{-ms-flex-align:start;-ms-grid-row-align:flex-start;align-items:flex-start}[layout*=column][layout*=-center],[layout*=row][layout*=center-],[layout~=centered]{-ms-flex-align:center;-ms-grid-row-align:center;align-items:center}[layout*=column][layout*=-right],[layout*=row][layout*=bottom-]{-ms-flex-align:end;-ms-grid-row-align:flex-end;align-items:flex-end}[layout*=column][layout*=-stretch],[layout*=row][layout*=stretch-]{-ms-flex-align:stretch;-ms-grid-row-align:stretch;align-items:stretch}[layout*=columns][layout*=-left],[layout*=rows][layout*=top-]{-ms-flex-line-pack:start;align-content:flex-start}[layout*=columns][layout*=-right],[layout*=rows][layout*=bottom-]{-ms-flex-line-pack:end;align-content:flex-end}[layout*=columns][layout*=-center],[layout*=rows][layout*=center-]{-ms-flex-line-pack:center;align-content:center}[layout*=columns][layout*=-justify],[layout*=rows][layout*=justify-]{-ms-flex-line-pack:justify;align-content:space-between}[layout*=columns][layout*=-spread],[layout*=rows][layout*=spread-]{-ms-flex-line-pack:distribute;align-content:space-around}[layout*=columns][layout*=-stretch],[layout*=rows][layout*=stretch-]{-ms-flex-line-pack:stretch;align-content:stretch}@media (-ms-high-contrast:none),screen and (-ms-high-contrast:active){[layout*=column]:not([layout*=row])\u003E*{max-width:auto}[layout*=column][self*=top]{height:auto!important}[self~=size-]\u003E*{height:auto}}[layout*=column]:not([layout*=row]) [self*=left],[layout*=row]:not([layout*=column]) [self*=top]{-ms-flex-item-align:start;align-self:flex-start}[self~=center]{-ms-flex-item-align:center;align-self:center}[layout*=column]:not([layout*=row]) [self*=right],[layout*=row]:not([layout*=column]) [self*=bottom]{-ms-flex-item-align:end;align-self:flex-end}[self*=stretch]{-ms-flex-item-align:stretch;align-self:stretch}[layout][self*=center]{margin-left:auto;margin-right:auto}[layout][self*=right]{margin-right:0}[layout][self*=left]{margin-left:0}[layout*=column] [self*=bottom]{margin-top:auto}[layout*=column] [self*=top]{margin-bottom:auto}[layout*=row] [self*=left]{margin-right:auto}[layout*=row] [self*=right]{margin-left:auto}[self~=size-1of5]{width:20%}[self~=size-1of4]{width:25%}[self~=size-1of3]{width:33.33333%}[self~=size-2of5]{width:40%}[self~=size-1of2]{width:50%}[self~=size-3of5]{width:60%}[self~=size-2of3]{width:66.6666%}[self~=size-3of4]{width:75%}[self~=size-4of5]{width:80%}[self~=size-1of1]{width:100%}[layout*=column][layout*=stretch-]\u003E:not([self*=size-]),[layout*=row][layout*=-stretch]\u003E:not([self*=size-]),[self~=size-x1]{-ms-flex:1 0 0%!important;flex:1 0 0%!important}[self~=size-x2]{-ms-flex:2 0 0%!important;flex:2 0 0%!important}[self~=size-x3]{-ms-flex:3 0 0%!important;flex:3 0 0%!important}[self~=size-x4]{-ms-flex:4 0 0%!important;flex:4 0 0%!important}[self~=size-x5]{-ms-flex:5 0 0%!important;flex:5 0 0%!important}[self~=size-x6]{-ms-flex:6 0 0%!important;flex:6 0 0%!important}[self~=size-x7]{-ms-flex:7 0 0%!important;flex:7 0 0%!important}[self~=size-x8]{-ms-flex:8 0 0%!important;flex:8 0 0%!important}[self~=size-x9]{-ms-flex:9 0 0%!important;flex:9 0 0%!important}[self*=size-auto]{-ms-flex:1 1 auto;flex:1 1 auto}[self*=size-x0]{-ms-flex:0 0 auto;flex:0 0 auto}[self~=size-xxlarge]{max-width:1440px;width:100%}[self~=size-xlarge]{max-width:1200px;width:100%}[self~=size-large]{max-width:960px;width:100%}[self~=size-larger]{max-width:840px;width:100%}[self~=size-medium]{max-width:720px;width:100%}[self~=size-smaller]{max-width:600px;width:100%}[self~=size-small]{max-width:480px;width:100%}[self~=size-xsmall]{max-width:360px;width:100%}[self~=size-xxsmall]{max-width:240px;width:100%}[self*=size-x]:not([self*=small]):not([self*=large]){-ms-flex-negative:1;flex-shrink:1}[self~=first]{-ms-flex-order:-1;order:-1}[self~=order-1]{-ms-flex-order:1;order:1}[self~=order-2]{-ms-flex-order:2;order:2}[self~=order-3]{-ms-flex-order:3;order:3}[self~=last]{-ms-flex-order:999;order:999}[layout*=column]:not([layout*=row])\u003E*{-ms-flex-negative:0;flex-shrink:0;-ms-flex-preferred-size:auto;flex-basis:auto}@media screen and (max-width:64em){[layout*=lg-row]{-ms-flex-direction:row;flex-direction:row}[layout*=lg-column]{-ms-flex-direction:column;flex-direction:column}[layout*=lg-columns],[layout*=lg-rows]{-ms-flex-wrap:wrap;flex-wrap:wrap}}@media screen and (max-width:52em){[layout*=md-row]{-ms-flex-direction:row;flex-direction:row}[layout*=md-column]{-ms-flex-direction:column;flex-direction:column}[layout*=md-columns],[layout*=md-rows]{-ms-flex-wrap:wrap;flex-wrap:wrap}}@media screen and (max-width:40em){[layout*=sm-row]{-ms-flex-direction:row;flex-direction:row}[layout*=sm-column]{-ms-flex-direction:column;flex-direction:column}[layout*=sm-columns],[layout*=sm-rows]{-ms-flex-wrap:wrap;flex-wrap:wrap}}@media screen and (max-width:64em){[self*=lg-full]{-ms-flex:1 1 100%!important;flex:1 1 100%!important;width:100%;max-width:100%}[self*=lg-half]{-ms-flex:1 1 50%!important;flex:1 1 50%!important;width:50%;max-width:50%}[self~=lg-first]{-ms-flex-order:-1;order:-1}[self~=lg-last]{-ms-flex-order:999;order:999}[self~=lg-hide]{display:none}[self~=lg-show]{display:inherit}}@media screen and (max-width:52em){[self*=md-full]{-ms-flex:1 1 100%!important;flex:1 1 100%!important;width:100%;max-width:100%}[self*=md-half]{-ms-flex:1 1 50%!important;flex:1 1 50%!important;width:50%;max-width:50%}[self~=md-first]{-ms-flex-order:-1;order:-1}[self~=md-last]{-ms-flex-order:999;order:999}[self~=md-hide]{display:none}[self~=md-show]{display:inherit}}@media screen and (max-width:40em){[self*=sm-full]{-ms-flex:1 1 100%!important;flex:1 1 100%!important;width:100%;max-width:100%}[self*=sm-half]{-ms-flex:1 1 50%!important;flex:1 1 50%!important;width:50%;max-width:50%}[self~=sm-first]{-ms-flex-order:-1;order:-1}[self~=sm-last]{-ms-flex-order:999;order:999}[self~=sm-hide]{display:none}[self~=sm-show]{display:inherit}}","controller":null,"using":"\u002F\u002Fzuixjs.github.io\u002Fzkit\u002Fcss\u002Fflex-layout-attribute.min.css"},{"componentId":"layout\u002Ffooter","view":"\u003Cbutton class=\"active\"\u003E\n  \u003Ci class=\"material-icons md-48\"\u003Ehome\u003C\u002Fi\u003E\n\u003C\u002Fbutton\u003E\n\u003Cbutton\u003E\n  \u003Ci class=\"material-icons md-48\"\u003Emap\u003C\u002Fi\u003E\n\u003C\u002Fbutton\u003E\n\u003Cbutton\u003E\n  \u003Ci class=\"material-icons md-48\"\u003Elocal_drink\u003C\u002Fi\u003E\n\u003C\u002Fbutton\u003E\n\u003Cbutton\u003E\n  \u003Ci class=\"material-icons md-48\"\u003Eaudiotrack\u003C\u002Fi\u003E\n\u003C\u002Fbutton\u003E","css":". {\n    position: fixed;\n    left:0; bottom:0; right: 0;\n    height: 56px;\n    \u002F* background: rgba(240,240,240,0.97); *\u002F\n    background: rgba(0,0,0,0.97);\n    border-top: solid 1px rgba(0,0,0,0.25);\n    box-shadow: 0 -6px 2px -2px rgba(100,100,100,0.25);\n    text-align: center;\n    z-index: 100;\n    overflow: hidden;\n}\n\nbutton {\n    padding: 12px;\n    max-height: 56px;\n    margin-left: 8px;\n    margin-right: 8px;\n    background: transparent;\n    border: none;\n    border-radius: 8px;\n    color: rgba(240,240,240,0.5);\n    -webkit-transition: all .3s; \u002F* Safari *\u002F\n    transition: all .3s;\n}\nbutton:hover {\n    background: rgba(255,255,255,0.25);\n}\nbutton:focus {outline:0;}\nbutton i {font-size: 32px !important;}\n\n.active {\n    transform: scale(1.2);\n    color: orange;\n    text-shadow:\n            1px 1px 0 orange,\n            -1px -1px 0 orange,\n            1px -1px 0 orange,\n            -1px 1px 0 orange,\n            1px 1px 0 orange;\n}\n","controller":function(){}},{"componentId":"pages\u002Fhome","view":"\u003Cdiv self=\"size-small center-center\"\u003E\n    \u003Ciframe src=\"https:\u002F\u002Fwww.facebook.com\u002Fevents\u002F814076395711896\u002F\" width=\"300\" height=\"380\" frameborder=\"0\" allowtransparency=\"true\" allow=\"encrypted-media\"\u003E\u003C\u002Fiframe\u003E\n\u003C\u002Fdiv\u003E","css":"","controller":function(){}},{"componentId":"pages\u002Fmap","view":"\u003C!-- \u003Cdiv self=\"stretch-stretch\" layout=\"row center-center\"\u003E --\u003E\n\u003Cdiv class=\"box\"\u003E\u003Ciframe\n        src=\"https:\u002F\u002Fwww.google.com\u002Fmaps\u002Fembed?pb=!1m18!1m12!1m3!1d5893.164393385241!2d19.3683209300737!3d51.73990120286878!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!3m3!1m2!1s0x471a357e77a8b8cd%3A0x687adb8ad1a4049f!2zS29sYXJza2EgMTY3LCA5MC0wMDEgxYHDs2TFug!5e0!3m2!1sen!2spl!4v1576932228172!5m2!1sen!2spl\"\n        allowfullscreen\u003E\u003C\u002Fiframe\u003E\n\u003C\u002Fdiv\u003E\n\u003C!-- \u003C\u002Fdiv\u003E --\u003E","css":"\u002F* .box {\n    position: relative;\n    padding-bottom: 10%;\n    padding-top: 25px;\n    height: 100%;\n    overflow: hidden;\n  }\n   *\u002F\n  .box iframe {\n    width:100%;\n    height:100%;\n    margin:0;\n    padding-top:20vw;\n    padding-bottom:10vw;\n\n    position:absolute;\n  }\n  ","controller":function(){}},{"componentId":"pages\u002Fdrinks","view":"\u003Cdiv class=\"message\" self=\"stretch-stretch\" layout=\"row center-center\"\u003E\n    \u003Cdiv\u003EDrineczki\u003C\u002Fdiv\u003E\n\u003C\u002Fdiv\u003E","css":".message {\n    color: darkgrey;\n    min-height: 100vh;\n    width: 100vw;\n    font-size: 200%;\n}\n.message i {\n    margin-left: 16px;\n    color: darkgrey;\n    font-size: 150%;\n}\n","controller":function(){}},{"componentId":"pages\u002Fabout","view":"\u003Cdiv self=\"size-small center-center\"\u003E\n\n    \u003Ch2\u003EPrawilna playlista\u003C\u002Fh2\u003E\n\n    \u003Ciframe src=\"https:\u002F\u002Fopen.spotify.com\u002Fembed\u002Fplaylist\u002F0w4Dh5V1zZo4cKWxoJp7Lx\" width=\"300\" height=\"380\" frameborder=\"0\" allowtransparency=\"true\" allow=\"encrypted-media\"\u003E\u003C\u002Fiframe\u003E\n\n\u003C\u002Fdiv\u003E","css":". {\n    color: black;\n    padding: 24px;\n    margin-top: 64px;\n    margin-bottom: 64px;\n}\n\nh1,h2,h3 {\n    color: grey;\n}\n\nh2 {\n    font-size: 130%;\n}\n\na, a:visited, a:hover {\n    font-weight: 700;\n    color: darkorange;\n    text-decoration: none;\n}\n\n.small {\n    font-size: 90%;\n}\n","controller":function(){}},{"componentId":"https:\u002F\u002Fzuixjs.github.io\u002Fzkit\u002Flib\u002Fcontrollers\u002Fview_pager","controller":function(cp) {
    const DEFAULT_PAGE_TRANSITION = {duration: 0.3, easing: 'ease'};
    const BOUNDARY_HIT_EASING = 'cubic-bezier(0.0,0.1,0.35,1.1)';
    const DECELERATE_SCROLL_EASING = 'cubic-bezier(0.0,0.1,0.35,1.0)';
    const LAYOUT_HORIZONTAL = 'horizontal';
    const LAYOUT_VERTICAL = 'vertical';
    const SLIDE_DIRECTION_FORWARD = 1;
    const SLIDE_DIRECTION_BACKWARD = -1;
    // state vars
    let currentPage = -1;
    let oldPage = 0;
    let slideTimeout = null;
    let slideIntervalMs = 3000;
    let slideDirection = SLIDE_DIRECTION_FORWARD;
    let updateLayoutTimeout = null;
    let inputCaptured = false;
    // options
    let layoutType = LAYOUT_HORIZONTAL;
    let enableAutoSlide = false;
    let enablePaging = false;
    let holdTouch = false;
    let passiveMode = true;
    let startGap = 0;
    let hideOffViewElements = false;
    // status
    let isDragging = false;
    let wasVisible = false;
    let isLazyContainer = false;
    let isFlying = false;
    let actualViewSize = {
        width: 0,
        height: 0
    };
    // timers
    let componentizeInterval = null;
    let componentizeTimeout = null;
    /** @typedef {ZxQuery} */
    let pageList = null;
    // Create a mutation observer instance to watch for child add/remove
    const domObserver = new MutationObserver(function(a, b) {
        // update child list and re-layout
        pageList = cp.view().children();
        updateLayout();
    });

    cp.init = function() {
        let options = cp.options();
        let view = cp.view();
        options.html = false;
        options.css = false;
        enablePaging = (options.enablePaging === true || (view.attr('data-o-paging') === 'true'));
        enableAutoSlide = (options.autoSlide === true || (view.attr('data-o-slide') === 'true'));
        passiveMode = (options.passive !== false && (view.attr('data-o-passive') !== 'false'));
        holdTouch = (options.holdTouch === true || (view.attr('data-o-hold') === 'true'));
        startGap = (options.startGap || view.attr('data-o-startgap'));
        if (options.verticalLayout === true || (view.attr('data-o-layout') === LAYOUT_VERTICAL)) {
            layoutType = LAYOUT_VERTICAL;
        }
        if (options.slideInterval != null) {
            slideIntervalMs = options.slideInterval;
        } else if (view.attr('data-o-slide-interval') != null) {
            slideIntervalMs = parseInt(view.attr('data-o-slide-interval'));
        }
        hideOffViewElements = (options.autohide === true || (view.attr('data-o-autohide') === 'true'));
    };

    cp.create = function() {
        // enable absolute positioning for items in this view
        const view = cp.view().css({
            'position': 'relative',
            'overflow': 'hidden'
        });
        // get child items (pages)
        pageList = view.children();
        // loading of images could change elements size, so layout update might be required
        view.find('img').each(function(i, el) {
            this.one('load', updateLayout);
        });
        // re-arrange view on layout changes
        zuix.$(window)
            .on('resize', function() {
                layoutElements(true);
            }).on('orientationchange', function() {
            layoutElements(true);
        });
        // Options for the observer (which mutations to observe)
        // Register DOM mutation observer callback
        domObserver.observe(view.get(), {
            attributes: false,
            childList: true,
            subtree: true,
            characterData: false
        });
        updateLayout();
        // Set starting page
        setPage(0);
        let tapTimeout = null;
        // gestures handling - load gesture_helper controller
        zuix.load('@lib/controllers/gesture_helper', {
            view: view,
            passive: passiveMode,
            startGap: startGap,
            on: {
                'gesture:touch': function(e, tp) {
                    inputCaptured = false;
                    stopAutoSlide();
                    dragStart();
                    if (holdTouch) tp.cancel();
                },
                'gesture:release': function(e, tp) {
                    dragStop(tp);
                    resetAutoSlide();
                },
                'gesture:tap': function(e, tp) {
                    if (tapTimeout != null) {
                        clearTimeout(tapTimeout);
                    }
                    tapTimeout = setTimeout(function() {
                        handleTap(e, tp);
                    }, 50);
                },
                'gesture:pan': handlePan,
                'gesture:swipe': handleSwipe
            },
            ready: function() {
                layoutElements(true);
            }
        });
        // public component methods
        cp.expose('page', function(number) {
            if (number == null) {
                return parseInt(currentPage);
            } else setPage(number, DEFAULT_PAGE_TRANSITION);
        }).expose('get', function(number) {
            return pageList.eq(number);
        }).expose('slide', function(activate) {
            if (activate === true) {
                resetAutoSlide();
            } else stopAutoSlide();
        }).expose('layout', function(mode) {
            if (mode == null) {
                return layoutType;
            } else if (mode === LAYOUT_VERTICAL) {
                layoutType = LAYOUT_VERTICAL;
            } else layoutType = LAYOUT_HORIZONTAL;
            updateLayout();
        }).expose('refresh', function() {
            layoutElements(true);
        }).expose('next', next)
            .expose('prev', prev)
            .expose('last', last)
            .expose('first', first);
    };

    cp.destroy = function() {
        if (domObserver != null) {
            domObserver.disconnect();
        }
    };

    function updateLayout() {
        if (updateLayoutTimeout != null) {
            clearTimeout(updateLayoutTimeout);
        }
        updateLayoutTimeout = setTimeout(layoutElements, 250);
    }
    function layoutElements(force) {
        if (!force && (isDragging || componentizeInterval != null)) {
            updateLayout();
            return;
        }
        // init elements
        pageList.each(function(i, el) {
            this.css({
                'position': 'absolute',
                'left': 0,
                'top': 0
            });
        });
        // measure
        const viewSize = getSize(cp.view().get());
        if (viewSize.width === 0 || viewSize.height === 0) {
            if (viewSize.height === 0 && cp.view().position().visible) {
                let maxHeight = 0;
                // guess and set view_pager height
                pageList.each(function(i, el) {
                    let size = getSize(el);
                    if (size.height > maxHeight) {
                        maxHeight = size.height;
                    }
                });
                if (viewSize.height < maxHeight) {
                    cp.view().css('height', maxHeight + 'px');
                }
            }
            // cannot measure view, try again later
            updateLayout();
            return;
        }
        actualViewSize = viewSize;
        // position elements
        let offset = 0;
        let isLazy = false;
        pageList.each(function(i, el) {
            let size = getSize(el);
            if (layoutType === LAYOUT_HORIZONTAL) {
                let centerY = (viewSize.height-size.height)/2;
                if (centerY < 0) centerY = 0; // TODO: centering with negative offset was not working
                transition(this, DEFAULT_PAGE_TRANSITION);
                position(this, offset, centerY);
                offset += size.width;
            } else {
                let centerX = (viewSize.width-size.width)/2;
                if (centerX < 0) centerX = 0; // TODO: centering with negative offset was not working
                transition(this, DEFAULT_PAGE_TRANSITION);
                position(this, centerX, offset);
                offset += size.height;
            }
            if (this.attr('data-ui-lazyload') === 'true'
                || this.find('[data-ui-lazyload="true"]').length() > 0) {
                isLazy = true;
            }
        });
        isLazyContainer = isLazy;

        // focus to current page
        setPage(currentPage);
        // start automatic slide
        if (pageList.length() > 1) {
            resetAutoSlide();
        }
    }

    function next() {
        let isLast = false;
        let page = parseInt(currentPage)+1;
        if (page >= pageList.length()) {
            page = pageList.length()-1;
            isLast = true;
        }
        setPage(page, DEFAULT_PAGE_TRANSITION);
        return !isLast;
    }
    function prev() {
        let isFirst = false;
        let page = parseInt(currentPage)-1;
        if (page < 0) {
            page = 0;
            isFirst = true;
        }
        setPage(page, DEFAULT_PAGE_TRANSITION);
        return !isFirst;
    }
    function first() {
        setPage(0, DEFAULT_PAGE_TRANSITION);
    }
    function last() {
        setPage(pageList.length()-1, DEFAULT_PAGE_TRANSITION);
    }

    function slideNext() {
        setPage(parseInt(currentPage) + slideDirection, DEFAULT_PAGE_TRANSITION);
        resetAutoSlide();
    }

    function resetAutoSlide(timeout) {
        stopAutoSlide();
        if (enableAutoSlide === true) {
            const visible = cp.view().position().visible;
            if (visible) {
                if (!wasVisible) {
                    zuix.componentize(cp.view());
                }
                slideTimeout = setTimeout(slideNext, slideIntervalMs);
            } else {
                slideTimeout = setTimeout(resetAutoSlide, 500);
            }
            wasVisible = visible;
        }
    }
    function stopAutoSlide() {
        if (slideTimeout != null) {
            clearTimeout(slideTimeout);
        }
    }

    function getItemIndexAt(x, y) {
        let focusedPage = 0;
        pageList.each(function(i, el) {
            let data = getData(this);
            focusedPage = i;
            const size = getSize(el);
            const rect = {
                x: data.position.x,
                y: data.position.y,
                w: size.width,
                h: size.height
            };
            if ((layoutType === LAYOUT_HORIZONTAL && (rect.x > x || rect.x+rect.w > x))
                || (layoutType === LAYOUT_VERTICAL && (rect.y > y || rect.y+rect.h > y))) {
                return false;
            }
        });
        return focusedPage;
    }

    function focusPageAt(tp, transition) {
        let vp = cp.view().position();
        let page = getItemIndexAt(tp.x-vp.x, tp.y-vp.y);
        setPage(page, transition != null ? transition : DEFAULT_PAGE_TRANSITION);
    }

    function setPage(n, transition) {
        oldPage = currentPage;
        if (n < 0) {
            slideDirection = SLIDE_DIRECTION_FORWARD;
            n = 0;
        } else if (n >= pageList.length()) {
            slideDirection = SLIDE_DIRECTION_BACKWARD;
            n = pageList.length() - 1;
        } else if (n !== currentPage) {
            slideDirection = (currentPage < n) ? SLIDE_DIRECTION_FORWARD : SLIDE_DIRECTION_BACKWARD;
        }
        currentPage = n;
        if (currentPage != oldPage) {
            pageList.eq(currentPage).css('z-index', 1);
            if (oldPage !== -1) {
                pageList.eq(oldPage).css('z-index', 0);
            }
            cp.trigger('page:change', {in: currentPage, out: oldPage});
        }
        const el = pageList.eq(n);
        const data = getData(el);
        const elSize = getSize(el.get());
        const focusPoint = {
            x: (actualViewSize.width - elSize.width) / 2 - data.position.x,
            y: (actualViewSize.height - elSize.height) / 2 - data.position.y
        };
        flyTo(focusPoint, transition);
        resetAutoSlide();
    }

    function flyTo(targetPoint, transition) {
        const spec = getFrameSpec();
        const firstData = getData(pageList.eq(0));
        const lastPage = pageList.eq(pageList.length() - 1);
        const lastData = getData(lastPage);

        pageList.each(function(i, el) {
            const data = getData(this);
            const frameSpec = getFrameSpec();
            data.dragStart = {
                x: frameSpec.marginLeft + data.position.x,
                y: frameSpec.marginTop + data.position.y
            };
        });

        if (layoutType === LAYOUT_HORIZONTAL) {
            let x = targetPoint.x;
            if (firstData.position.x + targetPoint.x > 0) {
                x = -firstData.position.x;
            } else {
                if (lastData.position.x + lastPage.get().offsetWidth + targetPoint.x < actualViewSize.width) {
                    x = -spec.marginLeft*2 + actualViewSize.width - (lastData.position.x + lastPage.get().offsetWidth);
                }
            }
            // check if boundary was adjusted and adjust flying duration accordingly
            if (targetPoint.x-x !== 0 && transition != null) {
                transition = {
                    duration: transition.duration * (x / targetPoint.x),
                    easing: BOUNDARY_HIT_EASING
                };
                if (!isFinite(transition.duration) || transition.duration < 0) {
                    transition.duration = 0.2;
                }
            }
            dragShift(x, 0, transition);
        } else {
            let y = targetPoint.y;
            if (firstData.position.y + targetPoint.y > 0) {
                y = -firstData.position.y;
            } else {
                if (lastData.position.y + lastPage.get().offsetHeight + targetPoint.y < actualViewSize.height) {
                    y = -spec.marginTop*2 + actualViewSize.height - (lastData.position.y + lastPage.get().offsetHeight);
                }
            }
            // check if boundary was adjusted and adjust flying duration accordingly
            if (targetPoint.y-y !== 0 && transition != null) {
                transition = {
                    duration: transition.duration * (y / targetPoint.y),
                    easing: BOUNDARY_HIT_EASING
                };
                if (!isFinite(transition.duration) || transition.duration < 0) {
                    transition.duration = 0.2;
                }
            }
            dragShift(0, y, transition);
        }
        isFlying = true;
    }

    function getSize(el) {
        const rect = el.getBoundingClientRect();
        const width = rect.width || el.offsetWidth;
        const height = el.offsetHeight || rect.height;
        return {width: width, height: height};
    }

    function getData(el) {
        const data = el.get().data = el.get().data || {};
        data.position = data.position || {x: 0, y: 0};
        return data;
    }

    function componentizeStart() {
        if (isLazyContainer) {
            componentizeStop();
            if (componentizeTimeout != null) {
                clearTimeout(componentizeTimeout);
            }
            if (componentizeInterval != null) {
                clearInterval(componentizeInterval);
            }
            componentizeInterval = setInterval(function() {
                if (hideOffViewElements) {
                    pageList.each(function(i, el) {
                        // hide elements if not inside the view_pager
                        const computed = window.getComputedStyle(el, null);
                        const size = {
                            width: parseFloat(computed.width.replace('px', '')),
                            height: parseFloat(computed.height.replace('px', ''))
                        };
                        const x = parseFloat(computed.left.replace('px', ''));
                        const y = parseFloat(computed.top.replace('px', ''));
                        if (size.width > 0 && size.height > 0) {
                            el = zuix.$(el);
                            // check if element is inside the view_pager
                            if (x + size.width < 0 || y + size.height < 0 || x > actualViewSize.width || y > actualViewSize.height) {
                                if (el.visibility() !== 'hidden') {
                                    el.visibility('hidden');
                                }
                            } else if (el.visibility() !== 'visible') {
                                el.visibility('visible');
                            }
                        }
                    });
                }
                zuix.componentize(cp.view());
            }, 10);
        }
    }

    function componentizeStop() {
        if (isLazyContainer && componentizeTimeout == null) {
            clearInterval(componentizeInterval);
        }
    }

    function dragStart() {
        isDragging = true;
        isFlying = false;
        pageList.each(function(i, el) {
            const data = getData(this);
            const frameSpec = getFrameSpec();
            const computed = window.getComputedStyle(el, null);
            data.position.x = parseFloat(computed.left.replace('px', ''));
            data.position.y = parseFloat(computed.top.replace('px', ''));
            this.css('left', data.position.x+'px');
            this.css('top', data.position.y+'px');
            data.dragStart = {x: frameSpec.marginLeft+data.position.x, y: frameSpec.marginTop+data.position.y};
        });
    }

    function getFrameSpec() {
        const spec = {
            w: 0,
            h: 0,
            marginLeft: 0,
            marginTop: 0
        };
        pageList.each(function(i, el) {
            const size = getSize(el);
            spec.w += size.width;
            spec.h += size.height;
        });
        if (layoutType === LAYOUT_HORIZONTAL && spec.w < actualViewSize.width) {
            spec.marginLeft = (actualViewSize.width - spec.w) / 2;
        } else if (layoutType === LAYOUT_VERTICAL && spec.h < actualViewSize.height) {
            spec.marginTop = (actualViewSize.height - spec.h) / 2;
        }
        return spec;
    }

    function dragShift(x, y, tr) {
        if (tr != null) {
            componentizeStart();
            componentizeTimeout = setTimeout(function() {
                componentizeTimeout = null;
                componentizeStop();
            }, tr.duration*1000);
            tr = tr.duration+'s '+tr.easing;
        } else if (isLazyContainer) {
            zuix.componentize(cp.view());
        }
        pageList.each(function(i, el) {
            const data = getData(this);
            transition(this, tr);
            position(this, data.dragStart.x+x, data.dragStart.y+y);
        });
    }

    function dragStop(tp) {
        if (tp != null) {
            tp.done = true;
            // decelerate
            if (!isFlying && ((layoutType === LAYOUT_HORIZONTAL && tp.scrollIntent() === 'horizontal') || (layoutType === LAYOUT_VERTICAL && tp.scrollIntent() === 'vertical'))) {
                decelerate(null, tp);
            }
        }
        componentizeStop();
        isDragging = false;
    }

    // Gesture handling

    function handlePan(e, tp) {
        if (!tp.scrollIntent() || tp.done) {
            return;
        }
        if (inputCaptured
            || ((tp.direction === 'left' || tp.direction === 'right') && layoutType === LAYOUT_HORIZONTAL)
            || ((tp.direction === 'up' || tp.direction === 'down') && layoutType === LAYOUT_VERTICAL)) {
            // capture click event
            if (!inputCaptured && tp.event.touches == null) {
                cp.view().get().addEventListener('click', function(e) {
                    if (inputCaptured) {
                        inputCaptured = false;
                        e.cancelBubble = true;
                        // TODO: 'preventDefault' should not be used with passive listeners
                        e.preventDefault();
                    }
                    // release mouse click capture
                    cp.view().get().removeEventListener('click', this, true);
                }, true);
            }
            inputCaptured = true;
            tp.cancel();
        }
        const spec = getFrameSpec();
        if (layoutType === LAYOUT_HORIZONTAL && tp.scrollIntent() === 'horizontal') {
            dragShift(tp.shiftX-spec.marginLeft, 0);
        } else if (layoutType === LAYOUT_VERTICAL && tp.scrollIntent() === 'vertical') {
            dragShift(0, tp.shiftY-spec.marginTop);
        }
    }

    function handleTap(e, tp) {
        let vp = cp.view().position();
        let page = getItemIndexAt(tp.x-vp.x, tp.y-vp.y);
        cp.trigger('page:tap', page, tp);
        if (enablePaging) focusPageAt(tp);
    }

    function decelerate(e, tp) {
        const minSpeed = 0.01;
        const minStepSpeed = 1.25;
        const accelerationFactor = Math.exp(Math.abs(tp.velocity / (Math.abs(tp.velocity) <= minStepSpeed ? 5 : 2))+1);
        let friction = 0.990 + (accelerationFactor / 1000);
        if (friction > 0.999) {
            friction = 0.999;
        }
        const duration = Math.log(minSpeed / Math.abs(tp.velocity)) / Math.log(friction);
        const decelerateEasing = {
            duration: duration / 1000, // ms to s
            easing: DECELERATE_SCROLL_EASING
        };
        const fly = function(destination, shift) {
            if (enablePaging) {
                decelerateEasing.duration *= 0.5;
                if (layoutType === LAYOUT_HORIZONTAL) {
                    focusPageAt({
                        x: destination.x - shift.x,
                        y: destination.y
                    }, decelerateEasing);
                } else {
                    focusPageAt({
                        x: destination.x,
                        y: destination.y - shift.y
                    }, decelerateEasing);
                }
            } else {
                flyTo(shift, decelerateEasing);
            }
        };
        const flyingDistance = tp.stepSpeed < minStepSpeed ? 0 : accelerationFactor * tp.velocity * (1 - Math.pow(friction, duration + 1)) / (1 - friction);
        const ap = {
            x: flyingDistance,
            y: flyingDistance
        };
        if (willFly(tp) || e == null) fly(tp, ap);
    }

    function willFly(tp) {
        return (!enablePaging || Math.abs(tp.velocity) > 1.25);
    }

    function handleSwipe(e, tp) {
        if (willFly(tp)) {
            return;
        }
        switch (tp.direction) {
            case 'right':
                if (layoutType === LAYOUT_HORIZONTAL) prev();
                break;
            case 'left':
                if (layoutType === LAYOUT_HORIZONTAL) next();
                break;
            case 'down':
                if (layoutType === LAYOUT_VERTICAL) prev();
                break;
            case 'up':
                if (layoutType === LAYOUT_VERTICAL) next();
                break;
        }
    }

    function position(el, x, y) {
        const data = getData(el);
        if (!isNaN(x) && !isNaN(y)) {
            data.position = {'x': x, 'y': y};
            el.css({'left': data.position.x+'px', 'top': data.position.y+'px'});
        }
        return data;
    }

    function transition(el, transition) {
        if (transition == null) {
            transition = 'none';
        }
        el.css({
            '-webkit-transition': transition,
            '-moz-transition': transition,
            '-ms-transition': transition,
            '-o-transition': transition,
            'transition': transition
        });
    }
}},{"componentId":"https:\u002F\u002Fzuixjs.github.io\u002Fzkit\u002Flib\u002Fcontrollers\u002Fgesture_helper","view":"\n        \u003Cdiv style=\"z-index: 1; transition: none 0s ease 0s; left: -720px; top: 0px;\"\u003E\n            Top Stories\n        \u003C\u002Fdiv\u003E\n        \u003Cdiv style=\"transition: none 0s ease 0s; left: -720px; top: 0px;\"\u003E\n            World\n        \u003C\u002Fdiv\u003E\n        \u003Cdiv style=\"transition: none 0s ease 0s; left: -720px; top: 0px;\"\u003E\n            Europe\n        \u003C\u002Fdiv\u003E\n        \u003Cdiv style=\"transition: none 0s ease 0s; left: -720px; top: 0px;\"\u003E\n            Travel\n        \u003C\u002Fdiv\u003E\n    ","css":null,"controller":function(cp) {
    const SCROLL_MODE_NONE = 0;
    const SCROLL_MODE_HORIZONTAL = 1;
    const SCROLL_MODE_VERTICAL = 2;
    const GESTURE_TAP_TIMEOUT = 750;

    let scrollMode = SCROLL_MODE_NONE;
    let touchPointer;
    let ignoreSession = false;
    let passiveMode = true;
    let startGap = -1;
    let currentGesture;
    let swipeDirection;
    let speedMeter;
    let mouseButtonDown = false;
    let lastTapTime = new Date().getTime();

    // Math.sign Polyfill
    Math.sign = Math.sign || function(x) {
        return ((x>0)-(x<0))||+x;
    };

    cp.init = function() {
        let view = cp.view();
        const options = cp.options();
        options.html = false;
        options.css = false;
        passiveMode = (options.passive !== false && (view.attr('data-o-passive') !== 'false'));
        startGap = (options.startGap || view.attr('data-o-startgap'));
    };

    cp.create = function() {
        // TODO: should use event "capturing" instead of "bubbling"
        cp.view().on('dragstart', {
            handler: function(e) {
                if (!ignoreSession && !passiveMode) {
                    e.preventDefault();
                }
            },
            passive: passiveMode
        }).on('mousedown', {
            handler: function(e) {
                const targetElement = zuix.$(e.target);
                if (e.which === 1 && targetElement.parent('[class*="no-gesture"]').length() === 0 && e.x > startGap) {
                    mouseButtonDown = true;
                    ignoreSession = false;
                    // targetElement.css('touch-action', 'none');
                    // TODO: add 'cp.options().preventDrag'
                    targetElement.get().draggable = false;
                    touchStart(e, e.x, e.y);
                } else ignoreSession = true;
            },
            passive: passiveMode
        }).on('mousemove', {
            handler: function(e) {
                if (!ignoreSession && mouseButtonDown) {
                    touchMove(e, e.x, e.y);
                }
            },
            passive: passiveMode
        }).on('mouseup', function(e) {
            if (e.which === 1 && !ignoreSession) {
                mouseButtonDown = false;
                touchStop(e);
            }
        }).on('touchstart', {
            handler: function(e) {
                const targetElement = zuix.$(e.target);
                if (targetElement.parent('[class*="no-gesture"]').length() === 0 && e.touches[0].clientX > startGap) {
                    ignoreSession = false;
                    // targetElement.css('touch-action', 'none');
                    targetElement.get().draggable = false;
                    touchStart(e, e.touches[0].clientX, e.touches[0].clientY);
                } else ignoreSession = true;
            },
            passive: passiveMode
        }).on('touchmove', {
            handler: function(e) {
                if (!ignoreSession) {
                    touchMove(e, e.touches[0].clientX, e.touches[0].clientY);
                }
            },
            passive: passiveMode
        }).on('touchend', function(e) {
            if (!ignoreSession) {
                touchStop(e);
            }
        });
    };

    function touchStart(e, x, y) {
        let timestamp = new Date().getTime();
        touchPointer = {
            // original event + cancel method
            event: e,
            cancel: function() {
                touchPointer.event.cancelBubble = true;
                if (!passiveMode) {
                    touchPointer.event.preventDefault();
                }
            },
            // initial touch position
            startX: x,
            startY: y,
            startTime: timestamp,
            // relative movement
            shiftX: 0,
            shiftY: 0,
            endTime: 0,
            // relative movement at every step
            stepX: 0,
            stepY: 0,
            stepTime: timestamp,
            // actual position and speed
            velocity: 0,
            x: x,
            y: y,
            scrollIntent: function() {
                switch (scrollMode) {
                    case SCROLL_MODE_HORIZONTAL:
                        return 'horizontal';
                    case SCROLL_MODE_VERTICAL:
                        return 'vertical';
                }
                return false;
            }
        };
        speedMeter = speedObserver(touchPointer);
        cp.trigger('gesture:touch', touchPointer);
    }
    function touchMove(e, x, y) {
        if (touchPointer != null) {
            touchPointer.event = e;
            touchPointer.x = x;
            touchPointer.y = y;
            touchPointer.shiftX = (x - touchPointer.startX);
            touchPointer.shiftY = (y - touchPointer.startY);
            touchPointer.endTime = new Date().getTime();
            // detect actual gesture
            let gesture = detectGesture();
            if (gesture != null && currentGesture !== false) {
                if (swipeDirection != null && swipeDirection !== touchPointer.direction) {
                    // stop gesture detection if not coherent
                    currentGesture = false;
                    swipeDirection = 'cancel';
                } else {
                    currentGesture = gesture;
                    swipeDirection = touchPointer.direction;
                }
            }
            cp.trigger('gesture:pan', touchPointer);
        }
    }

    function touchStop(e) {
        if (touchPointer != null) {
            speedMeter.update();
            touchPointer.event = e;
            if (currentGesture == null) {
                currentGesture = detectGesture();
            }
            if (currentGesture != null && currentGesture !== false) {
                cp.trigger(currentGesture, touchPointer);
            }
        }
        cp.trigger('gesture:release', touchPointer);
        scrollMode = SCROLL_MODE_NONE;
        swipeDirection = null;
        currentGesture = null;
        touchPointer = null;
    }

    function detectGesture() {
        let gesture = null;
        // update touchPointer.velocity data
        speedMeter.update();
        // update tap gesture and swipe direction
        const minStepDistance = 2; // <--- !!! this should not be greater than 2 for best performance
        const angle = Math.atan2(touchPointer.shiftY-touchPointer.stepY, touchPointer.shiftX-touchPointer.stepX) * 180 / Math.PI;
        if ((touchPointer.shiftX) === 0 && (touchPointer.shiftY) === 0 && touchPointer.startTime > lastTapTime+100 && touchPointer.stepTime < GESTURE_TAP_TIMEOUT) {
            // gesture TAP
            lastTapTime = new Date().getTime();
            gesture = 'gesture:tap';
        } else if ((scrollMode === SCROLL_MODE_NONE || scrollMode === SCROLL_MODE_HORIZONTAL)
            && touchPointer.stepDistance > minStepDistance && ((angle >= 135 && angle <= 180) || (angle >= -180 && angle <= -135))) {
            // gesture swipe RIGHT
            touchPointer.direction = 'left';
            gesture = 'gesture:swipe';
            scrollMode = SCROLL_MODE_HORIZONTAL;
        } else if ((scrollMode === SCROLL_MODE_NONE || scrollMode === SCROLL_MODE_HORIZONTAL)
            && touchPointer.stepDistance > minStepDistance && ((angle >= 0 && angle <= 45) || (angle >= -45 && angle < 0))) {
            // gesture swipe LEFT
            touchPointer.direction = 'right';
            gesture = 'gesture:swipe';
            scrollMode = SCROLL_MODE_HORIZONTAL;
        } else if ((scrollMode === SCROLL_MODE_NONE || scrollMode === SCROLL_MODE_VERTICAL)
            && touchPointer.stepDistance > minStepDistance && (angle > 45 && angle < 135)) {
            // gesture swipe UP
            touchPointer.direction = 'down';
            gesture = 'gesture:swipe';
            scrollMode = SCROLL_MODE_VERTICAL;
        } else if ((scrollMode === SCROLL_MODE_NONE || scrollMode === SCROLL_MODE_VERTICAL)
            && touchPointer.stepDistance > minStepDistance && (angle > -135 && angle < -45)) {
            // gesture swipe DOWN
            touchPointer.direction = 'up';
            gesture = 'gesture:swipe';
            scrollMode = SCROLL_MODE_VERTICAL;
        }
        // reset touch step data
        if (touchPointer.stepDistance > minStepDistance) {
            speedMeter.step();
        }
        return gesture;
    }

    function speedObserver(tp) {
        let direction;
        let startData = {
            time: 0,
            x: 0, y: 0
        };
        let stopData = {
            time: 0,
            x: 0, y: 0
        };
        let step = function() {
            tp.stepTime = tp.endTime;
            tp.stepX = tp.shiftX;
            tp.stepY = tp.shiftY;
            tp.stepSpeed = 0;
            tp.stepDistance = 0;
        };
        let reset = function() {
            // direction changed: reset
            direction = tp.direction;
            startData.time = new Date().getTime();
            startData.x = tp.x;
            startData.y = tp.y;
            tp.velocity = 0;
            tp.distance = 0;
            step();
        };
        reset();
        return {
            update: function() {
                stopData.time = new Date().getTime();
                stopData.x = tp.x;
                stopData.y = tp.y;
                if (direction != null && direction !== tp.direction) {
                    reset();
                    return;
                } else if (direction == null && tp.direction !== direction) {
                    direction = tp.direction;
                }
                const elapsedTime = stopData.time - startData.time;
                let l = {x: (stopData.x - startData.x), y: (stopData.y - startData.y)};
                const d = Math.sqrt(l.x*l.x + l.y*l.y);
                tp.distance = d;
                // movement speed in px/ms
                let speed = (d / elapsedTime);
                // add the direction info
                tp.velocity = (tp.direction === 'left' || tp.direction === 'up') ? -speed : speed;
                // update "step" speed data
                tp.stepTime = (tp.endTime-tp.stepTime);
                l = {x: (tp.shiftX-tp.stepX), y: (tp.shiftY-tp.stepY)};
                tp.stepDistance = Math.sqrt(l.x*l.x+l.y*l.y);
                tp.stepSpeed = (tp.stepDistance / tp.stepTime);
            },
            step: step
        };
    }
}}]);